
List<String> names = Arrays.asList("Alice", "Bob", "Alice", "Alice", "Bob", "Charlie", "Charlie", "Bob");

Expected Output:
[
  "Alice (3)",
  "Bob (3)",
  "Charlie (2)"
]


Problem Statement:
You are given a list of strings representing people's names. Some of the names are duplicates. Your task is to:

Group the names by their frequency.
Sort the groups in descending order of frequency.
For groups with the same frequency, sort the names alphabetically.
Return the sorted result as a
list of strings, with each string formatted as: name (count).

Solve using java8 streams

	names.stream

 List<String> names = Arrays.asList("Alice", "Bob", "Alice", "Alice", "Bob", "Charlie", "Charlie", "Bob");
    names.stream().collect(Collectors.groupingBy(name -> name,Collectors.counting())).entrySet().stream().sorted((name1,name2) -> {
        if(name1.getValue()<name2.getValue()){
            return 1;
        }
        else if(name1.getValue()>name2.getValue()){
            return -1;
        }
        else{
            return name1.getKey().compareTo(name2.getKey());
        }
        
    }).forEach(s -> System.out.println(s.getKey()+"("+s.getValue()+")"));


1. Filter even numbers from a list of integers
Input:


List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Expected Output:


[2, 4, 6, 8, 10]

List<Integer> even=numbers.stream().filter(n -> n%2==0).collect(Collectors.toList()).forEach(Sytem.out::println());
  System.out.println(even);


2. Convert a list of strings to uppercase
Input:


List<String> names = Arrays.asList("alice", "bob", "charlie");
Expected Output:


["ALICE", "BOB", "CHARLIE"]
names.stream().map(String::toUpperCase).collect(Collectors.toList()).forEach(System.out::println);

3. Find the first string in a list that starts with "A"
Input:


List<String> names = Arrays.asList("Bob", "Alice", "Andrew", "Charlie");
Expected Output:


"Alice"
names.stream().filter(s -> s.startsWith("A")).collect(Collectors.toList()).forEach(System.out::println);

names.stream()
             .filter(s -> s.toLowerCase().startsWith("a")) // Convert to lowercase before filtering
             .collect(Collectors.toList())
             .forEach(System.out::println);
			 for case sensitive

4. Sort a list of integers in descending order
Input:


List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
Expected Output:


[9, 8, 5, 2, 1]
numbers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()).
    forEach(n -> System.out.print(n + " "));
5. Find the longest string in a list
Input:


List<String> words = Arrays.asList("apple", "banana", "cherry", "strawberry");
Expected Output:


"strawberry"

String word=words.stream().max(Comparator.comparingInt(String::length)).get();
    System.out.print(word);
	max and min accepts comparator.

    List<Integer> numbers = Arrays.asList(1,2,3,4,5);
    Integer max=numbers.stream().max(Integer::compareTo).get();
    System.out.println(max);
	
	List<String> list = Arrays.asList("Geeks", "for", "gfg", 
                                          "GeeksforGeeks", "GeeksQuiz");
	list.stream().mapToInt(str -> str.length()).forEach(System.out::println);
	
6. Check if all elements in a list are even numbers
Input:


List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);
Expected Output:


true
boolean response=numbers.stream().allMatch(n -> n%2==0);
    System.out.print(response);
7. Count the number of elements greater than 10 in a list
Input:


List<Integer> numbers = Arrays.asList(5, 12, 18, 3, 9, 20);
Expected Output:


3
List<Integer> numbers = Arrays.asList(5, 12, 18, 3, 9, 20);
    Long count=numbers.stream().filter(n -> n>10).count();
    System.out.print(count);
8. Remove duplicates from a list of integers
Input:


List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
Expected Output:


[1, 2, 3, 4, 5]
numbers.stream().collect(Collectors.toSet()).forEach(System.out::print);
9. Find the sum of all elements in a list of integers
Input:


List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Expected Output:


15
 List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
    Integer sum = numbers.stream().mapToInt(Integer::intValue).sum();
    System.out.print(sum);

15
List<Integer> numbers = Arrays.asList(10, 5, 20, 8, 15);
Integer secondHighest=numbers.stream().sorted(Comparator.reverseOrder()).skip(1).findFirst().get();
    
    System.out.print(secondHighest);
11. Group words by their first letter
Input:


List<String> words = Arrays.asList("apple", "banana", "apricot", "blueberry");
Expected Output:


{ 'a' -> ["apple", "apricot"], 'b' -> ["banana", "blueberry"] }
List<String> words = Arrays.asList("apple", "banana", "apricot", "blueberry");
    Map<Character,List<String>> map =	words.stream().collect(Collectors.groupingBy(s -> s.charAt(0)));
    System.out.print(map);
12. Count occurrences of each character in a string
Input:


String text = "hello";
Expected Output:


{ 'h' -> 1, 'e' -> 1, 'l' -> 2, 'o' -> 1 }
13. Group a list of people by age
Input:


List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 25)
);
Expected Output:


{ 25 -> [Alice, Charlie], 30 -> [Bob] }
people.stream().
    collect(Collectors.groupingBy(s -> s.getAge()))
    .forEach((key, value) -> System.out.println(key + " -> " + value));
	}
14. Find the most frequent word in a list
Input:


List<String> words = Arrays.asList("apple", "banana", "apple", "apple", "banana", "cherry");
Expected Output:


"apple"
15. Group numbers into odd and even categories
Input:


List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
Expected Output:


{ "even" -> [2, 4, 6], "odd" -> [1, 3, 5] }
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
  Map<Boolean, List<Integer>> partitioned = numbers.stream()
                .collect(Collectors.partitioningBy(n -> n % 2 == 0));
                
        System.out.println("Even Numbers: " + partitioned.get(true));
        System.out.println("Odd Numbers: " + partitioned.get(false));

16. Find duplicate elements in a list of strings
Input:


List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "banana");
Expected Output:


["apple", "banana"]

	words.stream()
                .collect(Collectors.groupingBy(s -> s, Collectors.counting())) // Count occurrences
                .entrySet().stream()
                .filter(entry -> entry.getValue() > 1) // Keep only duplicates
                .forEach(entry -> System.out.println(entry.getKey()));


21. Find the longest word in a sentence
Input:


String sentence = "The quick brown fox jumps over the lazy dog";
Expected Output:


"jumps"
String sentence = "The quicks brown fox jumps over the lazy dog";
	String longest = Arrays.stream(sentence.split(" ")).max(Comparator.comparingInt(String::length)).get();
	System.out.println(longest);



5
23. Find the average of numbers in a list
Input:


List<Integer> numbers = Arrays.asList(10, 20, 30, 40, 50);
Expected Output:


30.0
List<Integer> numbers = Arrays.asList(10, 20, 30, 40, 50);
OptionalDouble average = numbers.stream().mapToInt(Integer::intValue).average();
	
	System.out.println(average);

28. Find the common elements in two lists
Input:


List<Integer> list1 = Arrays.asList(1, 2, 3, 4);
List<Integer> list2 = Arrays.asList(3, 4, 5, 6);
Expected Output:


[3, 4]
list1.stream().filter(list2::contains).collect(Collectors.toSet()).forEach(System.out::print);

30. Find the first three elements of a list
Input:


List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");
Expected Output:


["Alice", "Bob", "Charlie"]
List<Integer> firstThree = numbers.stream()
                .limit(3) // Get only the first 3 elements
                .collect(Collectors.toList());

38. Concatenate two lists
Input:


List<Integer> list1 = Arrays.asList(1, 2, 3);
List<Integer> list2 = Arrays.asList(4, 5, 6);
Expected Output:


[1, 2, 3, 4, 5, 6]
List<Integer> mergedList = Stream.concat(list1.stream(), list2.stream())
                .collect(Collectors.toList());
				ðŸ‘‰ Example Input:
list1 = [1, 2, 3, 3], list2 = [3, 4, 5]
ðŸ‘‰ Output:
[1, 2, 3, 3, 3, 4, 5]

| Feature               | Future                                                                 | CompletableFuture                                                                                   |
|-----------------------|------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| Blocking vs Non-Blocking | Requires calling get(), which blocks until the result is available.  | Supports non-blocking execution with methods like thenApply, thenAccept, and thenRun.             |
| Callback Support      | No support for chaining or attaching callbacks.                       | Allows attaching callbacks to handle completion via thenApply, thenAccept, thenRun, etc.         |
| Exception Handling   | No built-in exception handling. Must handle exceptions externally when calling get(). | Supports exception handling using methods like exceptionally and handle.                          |
| Composing Results    | Does not support combining multiple Future instances or chaining tasks. | Supports composing results via methods like thenCompose, thenCombine, and parallel execution via allOf. |
| Use Cases            | Suitable for simple asynchronous tasks where you wait for the result later. | Ideal for complex async workflows, chaining tasks, combining results, and non-blocking operations. |

supplyAsync: Executes a task asynchronously and returns the result in a CompletableFuture.
runAsync: Executes a task asynchronously without returning any result.
thenApply: Transforms the result of a CompletableFuture once it completes.
thenAccept: Consumes the result of a CompletableFuture after completion without returning a value.
exceptionally: Handles exceptions in the async pipeline by providing a fallback value.

Future: It is generally used with an ExecutorService, and we get a Future object when we submit tasks to the executor. However, it doesnâ€™t allow us to define any computation steps 
to be executed once the computation is finished. The get() method is blocking, which means it waits until the task is completed and can make the application less responsive.

Additional Operations
Check if the Task is Complete: We can check if the computation is done by using futureResult.isDone().
Cancel the Task: If we need to cancel the computation, we can use futureResult.cancel(true).
Timeouts: We can set a timeout on the get() method to prevent indefinite blocking.

import java.util.concurrent.*;

public class FutureTimeoutExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Future<String> future = executor.submit(() -> {
            Thread.sleep(5000); // Simulating a long-running task
            return "Task Completed!";
        });

        try {
            System.out.println("Waiting for result with timeout...");
            String result = future.get(2, TimeUnit.SECONDS); // Wait up to 2 seconds
            System.out.println("Result: " + result);
        } catch (TimeoutException e) {
            System.out.println("Timeout occurred! Task took too long.");
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        executor.shutdown();
    }
}


CompletableFuture: It can be used as a Future and also allows us to attach callbacks via methods like thenApply, thenAccept, and thenRun. These methods let us execute additional 
actions upon completion of the original task, in a non-blocking fashion. CompletableFuture can also be manually completed.

// Using Future
ExecutorService executor = Executors.newFixedThreadPool(2);
Future<String> future = executor.submit(() -> {
    // Simulating long-running task
    Thread.sleep(2000);
    return "Hello, Future!";
});

try {
    // Blocking call, waiting for the result
    String result = future.get();
    System.out.println(result);
} catch (Exception e) {
    e.printStackTrace();
}

// Using CompletableFuture
CompletableFuture.supplyAsync(() -> {
    // Simulating long-running task
    try { Thread.sleep(2000); } catch (Exception e) {}
    return "Hello, CompletableFuture!";
})
.thenApply(result -> result + " with Async Chaining!")
.thenAccept(System.out::println)
.exceptionally(e -> {
    System.out.println("Exception occurred: " + e);
    return null;
});

executorService.execute(runnableTask);
Future<String> future = 
  executorService.submit(callableTask);
  executorService.shutdown();
  
  # Executor is the root Interface and ExecutorService is its implementation child class and ScheduledExecutorService is the child class or implementation class of ExecutorService.
  When we create bean of executorService by setting core pool size and queu capacity then we create object of ThreadPoolTaskExecutor and in end call .initialize() method and return.
  
  ExecutorService executor = Executors.newSingleThreadExecutor();
  ExecutorService fixedPool = Executors.newFixedThreadPool(2);
  ScheduledExecutorService scheduledExecService = Executors.newScheduledThreadPool(1);
  // Schedule the task to run every 3 seconds, with an initial delay of 1 second
        scheduler.scheduleAtFixedRate(task, 1, 3, TimeUnit.SECONDS);
		scheduleAtFixedRate()	At a fixed interval, even if the previous task is still running. Tasks that need regular execution (e.g., monitoring, polling)
		scheduleWithFixedDelay()	After the previous task completes + delay time. Tasks that require a gap between executions (e.g., cleanup, batch processing)
		
		Future CompletableFuture Executors all are in java.util.concurrent package
		
		scheduleExecutorService.schedule(() ->{System.out.println("Hello");}, 1, TimeUnit.SECONDS); it executed only once
		
		Set<String> set = new HashSet<String>();
		set.add("Rohit");
		set.add("rohit");
		
		System.out.println(set.size());  2
		
		Set<Person> set = new HashSet<>();
		set.add(new Person("Rohit",22));
		set.add(new Person("Rohit",22));
		
		System.out.println(set.size()); 1  hashcode and equals are overriden
		
		@Override
	public void run(ApplicationArguments args) throws Exception {
		List<Student> studentList = Stream.of(
                new Student(1, "Rohit", 30, "Male", "Mechanical Engineering", "Mumbai", 122, Arrays.asList("+912632632782", "+1673434729929")),
                new Student(2, "Pulkit", 56, "Male", "Computer Engineering", "Delhi", 67, Arrays.asList("+912632632762", "+1673434723929")),
                new Student(3, "Ankit", 25, "Female", "Mechanical Engineering", "Kerala", 164, Arrays.asList("+912632633882", "+1673434709929")),
                new Student(4, "Satish Ray", 30, "Male", "Mechanical Engineering", "Kerala", 26, Arrays.asList("+9126325832782", "+1671434729929")),
                new Student(5, "Roshan", 23, "Male", "Biotech Engineering", "Mumbai", 12, Arrays.asList("+012632632782")),
                new Student(6, "Chetan", 24, "Male", "Mechanical Engineering", "Karnataka", 90, Arrays.asList("+9126254632782", "+16736784729929")),
                new Student(7, "Arun", 26, "Male", "Electronics Engineering", "Karnataka", 324, Arrays.asList("+912632632782", "+1671234729929")),
                new Student(8, "Nam", 31, "Male", "Computer Engineering", "Karnataka", 433, Arrays.asList("+9126326355782", "+1673434729929")),
                new Student(9, "Sonu", 27, "Female", "Computer Engineering", "Karnataka", 7, Arrays.asList("+9126398932782", "+16563434729929", "+5673434729929")),
                new Student(10, "Shubham", 26, "Male", "Instrumentation Engineering", "Mumbai", 98, Arrays.asList("+912632646482", "+16734323229929")))
                .collect(Collectors.toList());
		
		/*
		 * 1. Find the list of students whose rank is in between 50 and 100
		 * List<Student> student=studentList.stream().filter(s -> s.getRank()>50 &&
		 * s.getRank()<100).collect(Collectors.toList());
		 * 
		 * output
		 * [Student{id=2, firstName='Pulkit', age=56, gender='Male', dept='Computer Engineering', city='Delhi', rank=67, contacts=[+912632632762, +1673434723929]},
		 *  Student{id=6, firstName='Chetan', age=24, gender='Male', dept='Mechanical Engineering', city='Karnataka', rank=90, contacts=[+9126254632782, +16736784729929]},
		 *   Student{id=10, firstName='Shubham', age=26, gender='Male', dept='Instrumentation Engineering', city='Mumbai', rank=98, contacts=[+912632646482, +16734323229929]}]
		 */
		
		
		/*
		 * 2. Find the Students who stays in Karnataka and sort them by their names
		 * List<Student> student=studentList.stream().filter(s -> s.getCity().equals("Karnataka")).sorted(Comparator.comparing(Student::getFirstName)).collect(Collectors.toList());
		[Student{id=7, firstName='Arun', age=26, gender='Male', dept='Electronics Engineering', city='Karnataka', rank=324, contacts=[+912632632782, +1671234729929]}, 
		Student{id=6, firstName='Chetan', age=24, gender='Male', dept='Mechanical Engineering', city='Karnataka', rank=90, contacts=[+9126254632782, +16736784729929]},
		 Student{id=8, firstName='Nam', age=31, gender='Male', dept='Computer Engineering', city='Karnataka', rank=433, contacts=[+9126326355782, +1673434729929]},
		 Student{id=9, firstName='Sonu', age=27, gender='Female', dept='Computer Engineering', city='Karnataka', rank=7, contacts=[+9126398932782, +16563434729929, +5673434729929]}]
		 
		 for reverse order 
		 List<Student> student=studentList.stream().filter(s -> s.getCity().equals("Karnataka")).sorted(Comparator.comparing(Student::getFirstName,Comparator.reverseOrder())).collect(Collectors.toList());
		 
		 */
		
		/*
		 * 3. Find all departments names
		 * studentList.stream().map(s -> s.getDept()).distinct().forEach(System.out::print);
		 * Mechanical EngineeringComputer EngineeringBiotech EngineeringElectronics EngineeringInstrumentation Engineering
		 */
		
		/*
		 * 4. Find all the contact numbers
		 * studentList.stream().flatMap(s -> s.getContacts().stream()).forEach(System.out::println);
		 * List<String> collect = studentList.stream().flatMap(s -> s.getContacts().stream()).distinct().collect(Collectors.toList());
		 * +912632632782
           +1673434729929
           +912632632762
           +1673434723929
		 */
		
		/*
		 * 5. Group The Student By Department Names
		 * Map<String, List<Student>> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getDept));
		
		for(Map.Entry<String,List<Student>> map:studentMap.entrySet()) {
			System.out.println(map);
		}
		
		Map<String, Long> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getDept,Collectors.counting()));
		
		for(Map.Entry<String,Long> map:studentMap.entrySet()) {
			System.out.println(map);
		}
		
		 */
		
		
		/*
		 * 6. Find the average age of male and female students
		 * Map<String, Double> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getGender,Collectors.averagingInt(Student::getAge)));
	
		for(Map.Entry<String,Double> map:studentMap.entrySet()) {
			System.out.println(map);
		}
		
		Female=26.0
		Male=30.75
		
		 */		
		
		/*
		 * 7. Find the highest rank in each department
		 * Map<String, Optional<Student>> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getDept,Collectors.minBy(Comparator.comparing(Student::getRank))));
		
		for(Map.Entry<String,Optional<Student>> map:studentMap.entrySet()) {
			System.out.println(map.getValue().get().getRank());
		}
		 */
		
		/*
		 * 8. List<Integer> numbers = Arrays.asList(3, 7, 8, 1, 5, 9); 
		 * int sum = numbers.stream().mapToInt(i -> i).sum(); 
		 * 
		 * Integer sum = numbers.stream().reduce(0, (a,b) -> a+b);
		 * Integer sum = numbers.stream().reduce(0, Integer::sum);
		 * System.out.println(sum); - > 33
		 * 
		 * List<Integer> numbers = Arrays.asList(3, 7, 8, 1, 5, 9);
		OptionalDouble sum = numbers.stream().mapToInt(i -> i).average();
		System.out.println(sum);
		 * 
		 */
		
		/*
		 * 9.List<String> projects = employees.stream()
                .flatMap(e -> e.getProjects().stream())
                .map(p -> p.getName()).distinct()
                .collect(Collectors.toList());
                Here project is also a class so map is called on it. 
		 */
		
		/*
		 * 10. Finding max rank
		 * Optional<Student> student = studentList.stream().max(Comparator.comparing(Student::getRank));
		 * 
		 * Optional<Employee> highestPaidEmployees = employees.stream()
                .max(Comparator.comparingDouble(Employee::getSalary));

       // System.out.println("Highest paid employee : "+highestPaidEmployees);

        Optional<Employee> lowestPaidEmployees = employees.stream()
                .min(Comparator.comparingDouble(Employee::getSalary));
		 * 
		 * 
		 */
		
		/*
		 * 11. Find first and Find any
		 * Employee findFirstElement = employees.stream()
                .filter(e -> e.getDept().equals("Development"))
                .findFirst()
                .orElseThrow(()->new IllegalArgumentException("Employee not found "));
		 */
		
		/*
		 * 12. Any match and All match
		 * 
		 * //anyMatch(Predicate) , allMatch(Predicate) , noneMatch(Predicate) Predicate accepts argument and return boolean
		 * 
		 * boolean developmentEmpAnyMatch = employees.stream()
                .anyMatch(e -> e.getDept().equals("Development"));
                 boolean developmentEmpAllMatch = employees.stream()
                .allMatch(e -> e.getSalary()>50000);//55000
                
                boolean isNoneMatch = employees.stream()
                .noneMatch(e -> e.getDept().equals("abc"));
		 */
	}
	
	Problem: Find the maximum value in a list of integers.
    Solution:
    Optional<Integer> max = numbers.stream()
    .max(Integer::compare);
	
	List of Names to Uppercase
	List<String> upperNames = names.stream()
	.map(String::toUpperCase)
	.collect(Collectors.toList());
	
	Problem: Sort a list of integers in ascending order.
	Solution:
	List<Integer> sortedNumbers = numbers.stream()
    .sorted()
    .collect(Collectors.toList());
	
	Count the number of elements in a list that are greater than 5.
	Solution:
	long count = numbers.stream()
	.filter(n -> n > 5)
	.count();
	
	int total = numbers.stream()
   .reduce(0, Integer::sum);
   
   The Stream. findFirst() method in Java returns an Optional containing the first element of the stream.
   
   /*
		 * 13 . List<Integer> numbers = Arrays.asList(3, 7, 8, 1, 5, 9);
		 * numbers.stream().limit(3).forEach(System.out::println); 3 7 8
		 */     
		
		/*14. 
		List<Integer> numbers = Arrays.asList(3, 7, 8, 1, 5, 9);
		numbers.stream()
				 .skip(2)
				 .collect(Collectors.toList()).forEach(i -> System.out.print(" " +i)); 8 1 5 9
		*/	
		
		/*
		 * 15. List<Integer> numbers = Arrays.asList(3, 7, 8, 1, 5, 9);
		 * numbers.stream().map(String::valueOf).filter(s ->
		 * s.startsWith("1")).forEach(System.out::println); 1
		 */
		
		/*
		 * 16. List<Integer> myList = Arrays.asList(10,15,8,49,25,98,98,32,15); int max
		 * = myList.stream() .max(Integer::compare) .get();
		 */
		 
		 