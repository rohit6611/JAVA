Sealed classes in Java 17 allow developers to control which classes can extend a given class

// Sealed class allowing only specific subclasses
public sealed class Vehicle permits Car, Bike {
    public void start() {
        System.out.println("Vehicle is starting...");
    }
}

// Permitted subclass
final class Car extends Vehicle {
    public void drive() {
        System.out.println("Car is driving...");
    }
}

// Permitted subclass
final class Bike extends Vehicle {
    public void ride() {
        System.out.println("Bike is riding...");
    }
}

// ‚ùå The following will cause a compilation error
// class Truck extends Vehicle {} // Not permitted!

public class Main {
    public static void main(String[] args) {
        Vehicle car = new Car();
        car.start(); // ‚úÖ Allowed
        ((Car) car).drive(); // ‚úÖ Allowed

        Vehicle bike = new Bike();
        bike.start(); // ‚úÖ Allowed
        ((Bike) bike).ride(); // ‚úÖ Allowed
    }
}

Prior to Java 17, switch worked only with primitive types, String, and enums. If we needed to handle different object types, 
we had to rely on if-else with instanceof and explicit type casting.

Before records, we had to manually write constructors, getters, toString(), equals(), and hashCode(), making the code verbose.

- Too much boilerplate code for a simple data class.
- Manually maintaining equals(), hashCode(), toString() is error-prone.
- Lack of immutability enforcement by default.

public record Employee(String name, int age) {}

public record Employee(String name, int age) {
    public String greet() {
        return "Hello, my name is " + name + " and I am " + age + " years old.";
    }
}

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("Alice", 30);
        System.out.println(emp.greet()); 
        // Output: Hello, my name is Alice and I am 30 years old.
    }
}

Before Java 16, using instanceof required explicit type casting after checking an object's type.
Problems in the Old Approach

Redundant Casting ((String) obj) even after instanceof check, More boilerplate code, NullPointerException.
Object obj = "Hello, Java 17!";

if (obj instanceof String str) {  // Direct variable declaration
    System.out.println(str.toUpperCase()); // null pointer in case of null 
}

In java 17 no explicit casting required and also no need to check for null
Object obj = null;

if (obj instanceof String str) { //  No need for explicit null checks
    System.out.println(str.toUpperCase());  // This won't execute
} else {
    System.out.println("Object is null"); 
}

ZGC (Z Garbage Collector) Enhancements ‚Äî Lower latency, better scalability.

Z Garbage Collector (ZGC) is a low-latency, scalable garbage collector introduced in Java 11 and improved in subsequent releases. Java 17 brings major enhancements, making it more efficient for large heaps and low-latency applications.

1. Encapsulation
Definition: Wrapping data (variables) and code (methods) together into a single unit (class), and restricting direct access.

Inheritance
Definition: Allows one class (child) to inherit fields and methods from another (parent).

Polymorphism
üìù Types:
Compile-time (Method Overloading)

Runtime (Method Overriding)

Example of Overloading (Compile-time Polymorphism)
public class MathUtils {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}


Example of Overriding (Runtime Polymorphism)
public class Animal {
    public void sound() {
        System.out.println("Animal makes sound");
    }
}

public class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}


Abstraction
Definition: Hiding internal details, showing only essential features.
Implemented via abstract classes or interfaces.

. Single Responsibility Principle (SRP)
A class should have only one reason to change, meaning it should have only one job or responsibility.

Open/Closed Principle (OCP)
Software entities (classes, modules, functions) should be open for extension, but closed for modification.

Liskov Substitution Principle (LSP)
Objects of a superclass should be replaceable with objects of its subclasses without breaking the program.

Interface Segregation Principle (ISP)
No client should be forced to depend on methods it does not use.

 Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules.
Both should depend on abstractions.

@Configuration
@ConditionalOnProperty(prefix = "feature.notifications", name = "enabled", havingValue = "true")
public class NotificationConfig {
    @Bean
    public NotificationService notificationService() {
        return new NotificationService();
    }
}

spring.application.name=my-client-app
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.instance.preferIpAddress=true


# Specifies the URL of the Spring Boot Admin Server. This is crucial for the client to register.
spring.boot.admin.client.url=http://localhost:8080 

# Enables or disables the Spring Boot Admin client functionality.
spring.boot.admin.client.enabled=true 


# Optional: If the Admin Server is secured, these properties are used for authentication.
# spring.boot.admin.client.username=admin
# spring.boot.admin.client.password=admin123

# Ignore the compiler error. Eclipse doesn't understand this.
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowedOrigins=*
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowedMethods=GET,POST,PUT,OPTIONS
spring.cloud.gateway.globalcors.corsConfigurations.[/**].allowCredentials=true

spring.cloud.gateway.routes[0].id=remote01
spring.cloud.gateway.routes[0].uri=lb://remote01
spring.cloud.gateway.routes[0].predicates[0].name=Path
spring.cloud.gateway.routes[0].filters[0]=JwtAuth=token,false

 List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4, 4, 5);
    Integer sum = numbers.stream().mapToInt(Integer::intValue).sum();
    System.out.print(sum);
    
     List<Integer> numbers = Arrays.asList(1,2,3,4,5);
    Integer max=numbers.stream().max(Integer::compareTo).get();
    System.out.println(max);
    
    int sum = numbers.stream().mapToInt(i -> i).sum(); 
    
    Optional<Student> student = studentList.stream().max(Comparator.comparing(Student::getRank));
    
    List<Integer> numbers = Arrays.asList(10, 5, 20, 8, 15);
Integer secondHighest=numbers.stream().sorted(Comparator.reverseOrder()).skip(1).findFirst().get();

Optional<Employee> lowestPaidEmployees = employees.stream()
                .min(Comparator.comparingDouble(Employee::getSalary));
                
                import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);      // minimum number of threads
        executor.setMaxPoolSize(10);      // max number of threads
        executor.setQueueCapacity(25);    // queue size before rejecting new tasks
        executor.setThreadNamePrefix("MyExecutor-");
        executor.initialize();
        return executor;
    }
}


SELECT salary
FROM employees
ORDER BY salary DESC
LIMIT 1 OFFSET 1;

SELECT *
FROM employee
WHERE salary = (
    SELECT DISTINCT salary
    FROM employee
    ORDER BY salary DESC
    LIMIT 1 OFFSET n - 1
);

UPDATE employees
SET salary = salary * 1.1
WHERE department = 'Sales';

ALTER TABLE employees
ADD COLUMN bonus DECIMAL(10,2);

ALTER TABLE employees
MODIFY COLUMN salary DECIMAL(12,2);

ALTER TABLE employees
RENAME COLUMN old_name TO new_name;

ALTER TABLE employees
DROP COLUMN bonus;

A clustered index sorts and stores the actual data rows in the table based on the indexed column(s).

There can be only one clustered index per table, because the data can be physically sorted in only one way.

-- When you create a PRIMARY KEY, it often becomes the clustered index
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL(10,2)
);


A non-clustered index creates a separate structure that has pointers (row locators) to the actual data rows.

The table data is not physically ordered by this index.

import java.util.Arrays;

public class AnagramCheck {
    public static void main(String[] args) {
        String str1 = "listen";
        String str2 = "silent";

        if (isAnagram(str1, str2)) {
            System.out.println(str1 + " and " + str2 + " are anagrams.");
        } else {
            System.out.println(str1 + " and " + str2 + " are NOT anagrams.");
        }
    }

    public static boolean isAnagram(String s1, String s2) {
        // Remove spaces and convert to lowercase
        s1 = s1.replaceAll("\\s", "").toLowerCase();
        s2 = s2.replaceAll("\\s", "").toLowerCase();

        // Check length
        if (s1.length() != s2.length()) {
            return false;
        }

        // Convert to char array and sort
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);

        // Compare sorted arrays
        return Arrays.equals(arr1, arr2);
    }
}

public static boolean isPalindrome(String s) {
    s = s.replaceAll("\\s", "").toLowerCase();
    return s.equals(new StringBuilder(s).reverse().toString());
}

public class LargestAndSecondLargest {
    public static void main(String[] args) {
        int[] arr = {12, 35, 1, 10, 34, 1};

        findLargestAndSecondLargest(arr);
    }

    public static void findLargestAndSecondLargest(int[] arr) {
        if (arr == null || arr.length < 2) {
            System.out.println("Array must contain at least two elements.");
            return;
        }

        int largest = Integer.MIN_VALUE;
        int secondLargest = Integer.MIN_VALUE;

        for (int num : arr) {
            if (num > largest) {
                secondLargest = largest;
                largest = num;
            } else if (num > secondLargest && num != largest) {
                secondLargest = num;
            }
        }

        System.out.println("Largest: " + largest);
        if (secondLargest == Integer.MIN_VALUE) {
            System.out.println("No second largest element found.");
        } else {
            System.out.println("Second Largest: " + secondLargest);
        }
    }
}

 System.out.println("Welcome to Online IDE!! Happy Coding :)");
        List<String> words = Arrays.asList("apple", "banana", "apple", "apple", "banana", "cherry");
        Map.Entry<String,Long> res=words.stream().collect(Collectors.groupingBy(s -> s,Collectors.counting())).entrySet().stream().
        max(Comparator.comparing(entry -> entry.getValue())).get();
        System.out.println(res.getKey());
        
        // String s = "local";
        // System.out.println(new StringBuilder(s).reverse());
        
        String s = "i love programming very much";
        String[] arr=s.split(" ");
        StringBuilder ans = new StringBuilder();
        for(int i=arr.length-1;i>0;i--){
            ans= ans.append(reverse(arr[i]));
            if(i!=0){
                ans=ans.append(" ");
            }
        }
        System.out.println(ans);
        
        
        When we try to dynamically load the class using Class.forName or ClassLoader.loadClass() that is not present in the classpath then we 
        face ClassNotFoundException.
        When class was present during compiletime,but missing when loading JVM tries to load dynamically then we encounter NoClassDefFoundError.
        
        Class.forName(String className)
        Loads the class by name (fully qualified class name like "com.example.MyClass").
        Also initializes it immediately (runs static initializers and static blocks).

	ClassLoader.loadClass
	Only loads the class, does NOT initialize it immediately (no static blocks are run).
	
	
	package com.journaldev.singleton;

public class LazyInitializedSingleton {

    private static LazyInitializedSingleton instance;

    private LazyInitializedSingleton(){}

    public static LazyInitializedSingleton getInstance() {
        if (instance == null) {
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}

List<String> words = Arrays.asList("apple", "banana", "apple", "apple", "banana", "cherry");
        Map.Entry<String,Long> res=words.stream().collect(Collectors.groupingBy(s -> s,Collectors.counting())).entrySet().stream().
        max(Comparator.comparing(entry -> entry.getValue())).get();
        System.out.println(res.getKey());
        
        String s = "local";
        System.out.println(new StringBuilder(s).reverse());
        
        String s = "i love programming very much";
        String[] arr=s.split(" ");
        StringBuilder ans = new StringBuilder();
        for(int i=arr.length-1;i>0;i--){
            ans= ans.append(reverse(arr[i]));
            if(i!=0){
                ans=ans.append(" ");
            }
        }
        System.out.println(ans);
    }
    
    public static StringBuilder reverse(String s){
        return new StringBuilder(s).reverse();
    }
    
    List<Integer> list = Arrays.asList(1,4,5,7,10);
    int sum = list.stream().mapToInt(Integer::intValue).sum();
System.out.println(sum);

    
    int sum = list.stream().mapToInt(Integer::intValue).sum();
    System.out.println(sum);
    
    selection sort - 
    int arr[] = {2,16,3,7,3,8,17,467,15,74,24};
     int n = arr.length;
     for(int i=0;i<n-1;i++)
     {
         int minidx = i;
         for(int j=i+1;j<n;j++)
         {
             if(arr[minidx]>arr[j])
             {
                 minidx = j;
             }
         }
         int temp = arr[minidx];
             arr[minidx]=arr[i];
             arr[i]=temp;
     }
     System.out.print(Arrays.toString(arr));
     
     bubble sort -
     int arr[] = {2,16,3,7,3,8,17,467,15,74,24};
     int n = arr.length;
     for(int i=0;i<n-1;i++)
     {
         for(int j=0;j<n-1-i;j++)
         {
             if(arr[j]>arr[j+1])
             {
                 int temp = arr[j];
             arr[j]=arr[j+1];
             arr[j+1]=temp;
             }
         }
         
     }
     System.out.print(Arrays.toString(arr));
     
     merge sort - 
     public class Main
{
    public static void main(String[] args) {
     
     int arr[] = {2,16,3,7,3,8,17,467,15,74,24};
     int n = arr.length;
     int low = 0;
     int high = arr.length-1;
     merge(arr,low,high);
     
     System.out.print(Arrays.toString(arr));
        
    }
    
    public static void merge(int[] arr,int low,int high){
        if(low<high){
            int mid = low + (high-low)/2;
            merge(arr,low,mid);
            merge(arr,mid+1,high);
            sort(arr,low,mid,high);
        }
    }
        
        public static void sort(int[] arr,int low,int mid,int high){
            int k = low;
            int n1 = mid-low+1;
            int n2=high-mid;
            int[] left = new int[n1];
            int[] right = new int[n2];
            for(int i=0;i<n1;i++){
                left[i] = arr[low+i];
            }
            for(int i=0;i<n2;i++){
                right[i]=arr[mid+1+i];
            }
            
            int i=0,j=0;
            while(i<n1 && j<n2){
                if(left[i]<=right[j]){
                    arr[k]=left[i];
                    i++;
                }
               else{
                    arr[k] = right[j];
                    j++;
                }
                k++;
            }
            while(i<n1){
                arr[k]=left[i];
                i++;k++;
            }
            while(j<n2){
                arr[k]=right[j];
                j++;k++;
            }
        }
}


quick sort - 
public class Main
{
    public static void main(String[] args) {
     
     int arr[] = {2,16,3,7,3,8,17,467,15,74,24};
     int n = arr.length;
     int low = 0;
     int high = arr.length-1;
     quick(arr,low,high);
     
     System.out.print(Arrays.toString(arr));
        
    }
    
    public static void quick(int[] arr,int s,int e){
        if(s>=e)
        {
            return;
        }
        int low=s;
        int high=e;
        int mid=s+(e-s)/2;
        int pivot = arr[mid];
        while(s<=e)
        {
            while(arr[s]<pivot)
            {
                s++;
            }
            while(arr[e]>pivot)
            {
                e--;
            }
            if(s<=e){
                int temp=arr[s];
                arr[s]=arr[e];
                arr[e]=temp;
                s++;e--;
            }
        }
        quick(arr,s,high);
        quick(arr,low,e);
        
        
    }
}

List<String> words = Arrays.asList("apple", "banana", "cherry", "strawberry");
Expected Output:


"strawberry"

String word=words.stream().max(Comparator.comparingInt(String::length)).get();
    System.out.print(word);
	max and min accepts comparator.
	
	List<String> list = Arrays.asList("Geeks", "for", "gfg", 
                                          "GeeksforGeeks", "GeeksQuiz");
	list.stream().mapToInt(str -> str.length()).forEach(System.out::println);
	
	List<Integer> numbers = Arrays.asList(5, 12, 18, 3, 9, 20);
    Long count=numbers.stream().filter(n -> n>10).count();
    System.out.print(count);
    
    @Configuration
@EnableAutoConfiguration
@ComponentScan


List<String> words = Arrays.asList("apple", "banana", "apple", "apple", "banana", "cherry");
   List<Map.Entry<String, Long>> map = words.stream().collect(Collectors.groupingBy(s -> s,Collectors.counting())).entrySet().stream().sorted(
       (m1,m2) -> {
           if(m1.getValue()<m2.getValue()){
               return 1;
           }else{
               return -1;
           }
       } ).collect(Collectors.toList());
       
       System.out.println(map.get(0).getKey());
       
       List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "banana");
Expected Output:


["apple", "banana"]

	words.stream()
                .collect(Collectors.groupingBy(s -> s, Collectors.counting())) // Count occurrences
                .entrySet().stream()
                .filter(entry -> entry.getValue() > 1) // Keep only duplicates
                .forEach(entry -> System.out.println(entry.getKey()));
                
                ["Alice", "Bob", "Charlie"]
List<Integer> firstThree = numbers.stream()
                .limit(3) // Get only the first 3 elements
                .collect(Collectors.toList());

List<String> list = Arrays.asList("abc","abaae3","ebe","ebabe");
      
      list.stream().limit(2).map(s -> s.length()).forEach(System.out::println); // outputs 3,6
                
                1, 2, 3, 4, 5, 6]
List<Integer> mergedList = Stream.concat(list1.stream(), list2.stream())
                .collect(Collectors.toList());
                
                 Find all the contact numbers
		 * studentList.stream().flatMap(s -> s.getContacts().stream()).forEach(System.out::println);
		 * List<String> collect = studentList.stream().flatMap(s -> s.getContacts().stream()).distinct().collect(Collectors.toList());
		 
		 Find the average age of male and female students
		 * Map<String, Double> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getGender,Collectors.averagingInt(Student::getAge)));
		 
		 Find the highest rank in each department
		 * Map<String, Optional<Student>> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getDept,Collectors.minBy(Comparator.comparing(Student::getRank))));
		 
		 List<Integer> numbers = Arrays.asList(3, 7, 8, 1, 5, 9);
		 * numbers.stream().map(String::valueOf).filter(s ->
		 * s.startsWith("1")).forEach(System.out::println); 1
		 */
		 
		 ist<Integer> myList = Arrays.asList(10,15,8,49,25,98,98,32,15); int max
		 * = myList.stream() .max(Integer::compare) .get();
		 
		 reverse array - 
		 public class Main
{
    public static void main(String[] args) {
     
   int[] arr = {2, 4, 6, 8, 10};
   int i = 0,j=arr.length-1;
   while(i<j){
       int temp=arr[i];
       arr[i]=arr[j];
       arr[j]=temp;
       i++;j--;
   }
        System.out.println(Arrays.toString(arr));
    }
    
    Try-with-resources statement is a try statement that declares one or more resources in it. A resource is an object that must be closed once your program is done using it. For example, a File resource or a Socket connection resource.  The try-with-resources statement ensures that each resource is closed at the end of the statement execution. If we don‚Äôt close the resources, it may constitute a resource leak and also the program could exhaust the resources available to it.
    
    public class Main
{
    public static void main(String[] args) {
     
   int[] arr = {2, 3, -8, 7, -1, 2, 3};
   
   int res = arr[0];
   
   
   for(int i=0;i<arr.length;i++)
   {
       int currsum=0;
       for(int j=i;j<arr.length;j++)
       {
           currsum+=arr[j];
           res = Math.max(res,currsum);
       }
   }
   System.out.println(res);
    }
    
    
}


public class Main
{
    public static void main(String[] args) {
     
   String[] strs = {"flower", "flow", "flight"};
   
   System.out.println(longestCommonPrefix(strs));
    
        
    }
    
    public static String longestCommonPrefix(String[] strs){
        
        if(strs==null || strs.length==0)
        {
            return null;
        }
        
        String prefix = strs[0];
        for(int i=1;i<strs.length;i++)
        {
            while(strs[i].indexOf(prefix)!=0)
            {
                prefix = prefix.substring(0,prefix.length()-1);
                if(prefix.isEmpty())
                {
                    return "";
                }
            }
        }
        return prefix;
        
    }
    
    
}

The heap is a region of memory in the JVM (Java Virtual Machine) where objects are stored.

Whenever you use new to create an object, it is allocated in the heap memory.

Young Generation (Eden + Survivor spaces)

Newly created objects are first allocated here.

The young gen is further divided into:

Eden space: Where most new objects are initially created.

Survivor spaces (S0 & S1): Where objects are moved after surviving a garbage collection cycle.

Old Generation (Tenured)

Objects that live long enough (survive multiple GCs) are promoted here.

It‚Äôs typically collected less frequently but takes longer to collect.

// Java Program to print pattern
// Square hollow pattern
import java.util.*;

public class Geeks {
    
    // Function to demonstrate pattern
    public static void printPattern(int n)
    {
        int i, j;
        
        // outer loop to handle number of rows
        for (i = 0; i < n; i++) {
            
            //  inner loop to handle number of columns
            for (j = 0; j < n; j++) {
                
                // star will print only when  it is in first
                // row or last row or first column or last
                // column
                if (i == 0 || j == 0 || i == n - 1
                    || j == n - 1) {
                    System.out.print("*");
                }
                
                // otherwise print space only
                else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }

    // Driver Function
    public static void main(String args[])
    {
        int n = 6;
        printPattern(n);
    }
}
******
*    *
*    *
*    *
*    *
******

// Java Program to print pattern
// Number-increasing pyramid 
import java.util.*;

public class Geeks {
    
    // Function to demonstrate pattern
    public static void printPattern(int n)
    {
        int i, j;
        
        // outer loop to handle number of rows
        for (i = 1; i <= n; i++) {
            
            // inner loop to handle number of columns
            for (j = 1; j <= i; j++) {
                
                // printing column values 
                // upto the row value
                System.out.print(j + " ");
            }

            // print new line for each row
            System.out.println();
        }
    }

    // Driver Function
    public static void main(String args[])
    {
        int n = 6;
        printPattern(n);
    }
}
1 
1 2 
1 2 3 
1 2 3 4 
1 2 3 4 5 
1 2 3 4 5 6 

// Java Program to print pattern
// Number-increasing reverse pyramid
import java.util.*;

public class Geeks {
    
    // Function to demonstrate pattern
    public static void printPattern(int n)
    {
        int i, j;
        
        // outer loop to handle number of rows
        for (i = n; i >= 1; i--) {
            
            // inner loop to handle number of columns
            for (j = 1; j <= i; j++) {
                
                // printing column values 
                // upto the row value
                System.out.print(j + " ");
            }

            // print new line for each row
            System.out.println();
        }
    }

    // Driver Function
    public static void main(String args[])
    {
        int n = 6;
        printPattern(n);
    }
}
1 2 3 4 5 6 
1 2 3 4 5 
1 2 3 4 
1 2 3 
1 2 
1 

// Java Program to print pattern
// Number-changing pyramid
import java.util.*;

// Java code for printing pattern
public class Geeks {
    
    // Function to demonstrate pattern
    public static void printPattern(int n)
    {
        int i, j;
        int num = 1;
        
        // outer loop to handle number of rows
        for (i = 1; i <= n; i++) {
            
            // inner loop to handle number of columns
            for (j = 1; j <= i; j++) {
                
                // printing value of num in each iteration
                System.out.print(num + " ");
                
                // increasing the value of num
                num++;
            }

            // printing new line for each row
            System.out.println();
        }
    }

    // Driver Function
    public static void main(String args[])
    {
        int n = 6;
        printPattern(n);
    }
}

1 
2 3 
4 5 6 
7 8 9 10 
11 12 13 14 15 
16 17 18 19 20 21 

// Java Program to print pattern
// Zero-One triangle
import java.util.*;

public class Geeks {
    
    // Function to demonstrate pattern
    public static void printPattern(int n)
    {
        int i, j;
        
        //outer loop to handle number of rows
        for (i = 1; i <= n; i++) {
            
            //inner loop to handle number of columns
            for (j = 1; j <= i; j++) {
                
                // if the sum of (i+j) is even then print 1
                if ((i + j) % 2 == 0) {
                    System.out.print(1 + " ");
                }
                // otherwise print 0
                else {
                    System.out.print(0 + " ");
                }
            }

            //printing new line for each row
            System.out.println();
        }
    }

    // Driver Function
    public static void main(String args[])
    {
        int n = 6;
        printPattern(n);
    }
}

1 
0 1 
1 0 1 
0 1 0 1 
1 0 1 0 1 
0 1 0 1 0 1 

// Java Program to print
// Square fill pattern
import java.util.*;

public class Geeks {

    // Function to demonstrate pattern
    public static void printPattern(int n)
    {
        int i, j;

        // outer loop to handle rows
        for (i = 0; i < n; i++) {

            // inner loop to handle columns
            for (j = 0; j < n; j++) {
                System.out.print("*");
            }

            // printing new line for each row
            System.out.println();
        }
    }

    // Driver Function
    public static void main(String args[])
    {
        int n = 6;
        printPattern(n);
    }
}

******
******
******
******
******
******


public class Main
{
    public static void main(String[] args) {
    
    int arr[] = {1,3,5,8,7,9,11,13,17,19,32,36,74};
    int n = arr.length;
    for(int i=0;i<n-1;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            int sum = arr[i]+arr[j];
            for(int k =j+1;k<n;k++)
            {
                if(sum == arr[k])
                {
                    System.out.println("Found sum of - "+arr[i]+"+"+arr[j]+"="+arr[k]);
                }
            }
        }
    }
        
    }    
}

Thread vs multithreading

String[] arr=s.trim().split("\\s+"); to split by more than one space

 String s = "Hello my name is   Rohit  ";
        String output = Arrays.stream(s.trim().split("\\s+"))
        .collect(Collectors.collectingAndThen(
            Collectors.toList(),
            list -> {
                Collections.reverse(list);
                return list.stream();
            }
            )).collect(Collectors.joining(" "));
            
            System.out.println(output);
            
            output - Rohit is name my Hello
            
            
  In Java, String is immutable and final, meaning once created, its value cannot change.

Internally, all string literals are stored in a special memory area called the String Constant Pool (SCP),
which helps reuse and save memory.

üß© 2. Memory Areas Where Strings Are Stored
Area	Description
Heap Memory	Where all Java objects live. Strings created with new keyword go here.
String Constant Pool (SCP)	A special part of the heap that stores unique string literals. Reuses already existing strings.

3. How Strings Are Stored
‚úÖ Example 1
String s1 = "Rohit";
String s2 = "Rohit";


üëâ Both s1 and s2 point to the same object in the String Constant Pool.
Because "Rohit" literal already exists ‚Äî Java reuses it.

‚úÖ Example 2
String s1 = new String("Rohit");
String s2 = new String("Rohit");


üëâ Two different objects are created in the heap,
even though both contain the same value "Rohit".

‚úÖ SCP also has one "Rohit" literal, but these two are separate heap objects referring to that literal internally.

4. == vs .equals() for Strings
Operator	Compares	Example
==	References (memory address)	s1 == s2
.equals()	Values	s1.equals(s2)

String s1 = "Java";
String s2 = "Java";
System.out.println(s1 == s2);
‚úÖ Output: true
‚û°Ô∏è Both point to same literal in SCP.

String s1 = new String("Java");
String s2 = new String("Java");
System.out.println(s1 == s2);
‚ùå Output: false
‚û°Ô∏è Two different objects in heap memory.

String s1 = new String("Java");
String s2 = "Java";
System.out.println(s1 == s2);
‚ùå Output: false
‚û°Ô∏è s1 is heap object, s2 is SCP literal.

String s1 = new String("Java");
String s2 = s1.intern();
System.out.println(s2 == "Java");
‚úÖ Output: true
‚û°Ô∏è intern() returns reference from SCP.

String s1 = "Ja" + "va";
String s2 = "Java";
System.out.println(s1 == s2);
‚úÖ Output: true
‚û°Ô∏è Compile-time constant folding ‚Äî both are the same literal in SCP.

String part1 = "Ja";
String part2 = "va";
String s1 = part1 + part2;
String s2 = "Java";
System.out.println(s1 == s2);
‚ùå Output: false
‚û°Ô∏è Because concatenation with variables happens at runtime, creating a new object in heap, not SCP.

String s1 = "Java";
s1.concat("World");
System.out.println(s1);
‚úÖ Output: Java
‚û°Ô∏è Strings are immutable. concat() creates a new object but doesn‚Äôt modify the original string.

Concept	Description
String literal	Stored in SCP, reused if same literal already exists
new String()	Creates new object in heap
intern()	Moves/links string to SCP
Immutable	Once created, cannot be changed
==	Checks reference
.equals()	Checks value

String s1 = "Java" + "Rocks";
String s2 = "JavaRocks";
System.out.println(s1 == s2); // ?
Answer: ‚úÖ true
Reason:

"Java" + "Rocks" are string literals, so concatenation happens at compile-time.

Resulting "JavaRocks" is placed in String Constant Pool (SCP).

s1 and s2 refer to the same SCP object.

‚ùì Q2: Concatenation with Variables
java
Copy code
String part1 = "Java";
String part2 = "Rocks";
String s1 = part1 + part2;
String s2 = "JavaRocks";
System.out.println(s1 == s2); // ?
Answer: ‚ùå false
Reason:

part1 + part2 happens at runtime, creating a new String object in heap, not SCP.

s2 refers to SCP.

References are different.

Trick:

s1.intern() == s2 ‚Üí ‚úÖ true

Q3: Using intern()
String s1 = new String("Hello") + new String("World");
String s2 = "HelloWorld";
System.out.println(s1 == s2); // ?
s1 = s1.intern();
System.out.println(s1 == s2); // ?


Answer:

First print ‚Üí ‚ùå false (s1 is heap object)

After intern ‚Üí ‚úÖ true (s1 now points to SCP object)

Key Point:
intern() returns the SCP reference.

final String part1 = "Java";
final String part2 = "Rocks";
String s1 = part1 + part2;
String s2 = "JavaRocks";
System.out.println(s1 == s2); // ?
Answer: ‚úÖ true
Reason:

final variables are compile-time constants, so the concatenation is done at compile-time ‚Üí SCP.

Trick: Non-final variables ‚Üí concatenation happens at runtime ‚Üí heap object.

String s1 = new String("madam");
String s2 = new String("madam");
System.out.println(s1 == s2); // false
System.out.println(s1.intern() == s2.intern()); // true
Trick: Using intern() ensures SCP reference comparison works.

String s1 = "Hello";
String s2 = s1;
s1 = s1 + "World";
System.out.println(s2); // ?
System.out.println(s1); // ?
Answer:

s2 ‚Üí "Hello" (unchanged)

s1 ‚Üí "HelloWorld" (new object in heap)

Reason: String is immutable. Reassignment creates a new object

String.intern() method: This method returns the canonical representation of a string object.
If the string object (the one on which intern() is called) is already present in the String Constant Pool, the method returns a reference to that existing object in the pool.
If the string object is not in the pool, a copy of the string is created in the pool, and a reference to this newly added string is returned.

 int d = 3/2;
       System.out.println(d);
       output - 1
       
       Double d = 3/2.0;
       System.out.println(d);
       output - 1.5         same with 3.0/2    and 3.0/2.0
       
         Double d = (double)3/2;
       System.out.println(d);
       output - 1.5   can't typecast using (Double) as 3/2 returns primitive int.
       
       List<String> list = List.of("apple","banana","orange");
       System.out.println(
       String.join("",list).chars().filter(ch -> ch=='a').count());
       
       int[] arr = {1, 5, 0, 3, 2, 0, 0, 5};
       int count = 0;
       int n = arr.length;
       for(int i=0;i<n;i++)
       {
           if(arr[i]!=0)
           {
               arr[count++]=arr[i];
           }
       }
       while(count<n)
       {
           arr[count++]=0;
       }
       System.out.println(Arrays.toString(arr));
       
       output - [1, 5, 3, 2, 5, 0, 0, 0]
       
       ------------------------------Arrays to sort the array of 0 1 2---------------------------------------
       
       int[] arr = {1, 1, 0, 1, 2, 0, 0, 2};
       int count0 = 0,count1=0,count2=0;
       int i = 0;
       int n = arr.length;
       for(int j=0;j<n;j++)
       {
           if(arr[j]==0) count0++;
           
           if(arr[j]==1) count1++;
           
           if(arr[j]==2) count2++;
           
       }
       for(int k=0;k<count0;k++)
       {
           arr[i++]=0;
       }
       for(int k=0;k<count1;k++)
       {
           arr[i++]=1;
       }
       for(int k=0;k<count2;k++)
       {
           arr[i++]=2;
       }
       System.out.println(Arrays.toString(arr));
       
       
In Spring, a proxy is an object that wraps another object (the target bean) to intercept method calls before or after they reach the real object.
Think of it as a middleman ‚Äî whenever you call a method on your bean, the call actually goes through the proxy first.
The proxy can then:
Add extra behavior (like logging, transactions, async execution)
Decide whether or not to forward the call to the real bean
Modify the return value
These annotations need to run extra logic before/after your method ‚Äî proxies make that possible without modifying your code.

Client
   ‚Üì
Filter (Servlet level)
   ‚Üì
DispatcherServlet
   ‚Üì
Interceptor (Spring level)
   ‚Üì
Controller
   ‚Üì
Interceptor (postHandle)
   ‚Üì
View Rendering
   ‚Üì
Interceptor (afterCompletion)
   ‚Üì
Filter (response)
   ‚Üì
Client

Filters run before Spring MVC gets the request.
Interceptors run inside Spring MVC, just before the controller.

JwtAuthenticationEntryPoint - The global fallback handler for authentication failures.

A claim is a piece of information embedded inside a JWT.
Claims are key-value pairs that describe something about the user, the token, or any other data you want to transmit securely.

proxy acts as a substitute for the real object.

if you try to return a json and annotate the method with @Controller then it will convert the return value.toString() and then try to find that view
so you will encounter an error so to expect as expected you need to annotate extra with @ResponseBody.

Future is an interface that is used to get the result of the asynchronous operation. and it is blocking in nature though it executes in seperate thread and waits till
its operation is completed. we can get the result using get() method.

CompletableFuture is a class.
A CompletableFuture can be instantiated without arguments, providing a simple way to create a future that can be manually completed:
CompletableFuture<String> completableFuture = new CompletableFuture<>();
This basic form of CompletableFuture allows for explicit completion. Before completion, any attempt to retrieve its result will lead to blocking.
The get() method will block the calling thread indefinitely until the CompletableFuture is completed, which, in the initial state, it could wait forever if the future is never explicitly completed.
Completing the CompletableFuture: To prevent indefinite blocking and to supply a result to the waiting threads, you can complete the CompletableFuture manually:

The finally block always executes, even if an exception is thrown. But if an exception occurs within finally, it will override any previous exceptions.

String is immutable.
StringBuilder is mutable and not thread-safe.
StringBuffer is mutable and thread-safe due to synchronization.

What is applicationContext?
applicationContext is the central interface to the Spring IoC container. It is responsible for instantiating, configuring, and assembling the beans in the application. 
It acts as a container that holds all the beans and provides various functionalities such as dependency injection, event propagation, and resource loading.

Inversion of Control (IoC) is a principle where the control of creating and managing objects is transferred from the application code to the framework. In Spring, IoC is 
achieved through the Spring IoC container, which manages the beans and their dependencies.

What is Dependency Injection?
Dependency Injection is a technique where an object receives its dependencies from an external source rather than creating them itself.

String str = "I like Marvel Movies";
boolean doesContainsWhiteSpace = StringUtils.containsWhitespace(str);
Here doesContainsWhiteSpace will be true as the string contains white spaces.

We can remove all the white space using another StringUtils method as below:

String newString = StringUtils.trimAllWhitespace(str);
The value of newString in the above case will be IlikeMarvelMovies

Find the maximum value in the List<Integer>.
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int max = numbers.stream()
                 .max(Integer::compareTo)
// Above code uses method referene, 
// Below commented code uses lamnda expression.
// numbers.stream().max((a, b) -> a.compareTo(b));

2. Given List<Employee>, Find employee with higest salary.

List<Employee> employees = Arrays.asList(
            new Employee("John", 50000),
            new Employee("Jane", 60000),
            new Employee("Mark", 55000),
            new Employee("Sophia", 75000),
            new Employee("Alex", 40000)
        );

Optional<Employee> highestSalaryEmployee = employees.stream()
            .max(Comparator.comparingDouble(Employee::getSalary));	
            
             27 . public class A 
{ 
private void m1()
{ 
 System.out.println("m1-A"); 
 } 
} 
public class B extends A
{ 
private void m1()
{ 
 System.out.println("m1-B"); 
} 
public static void main(String[] args) 
{ 
 B b = new B(); 
 b.m1(); 
 } 
}
Ans: No, Compile time error.

Explanation: The overriding concept is not applicable to the private method. Parent class private method is not visible in the child class. Keep in mind. Based on our requirement, 
we can define exactly the same private method in the child class. The code is valid but not overriding.

Whenever you want to find sum or average convert to stream then then mapToInt and then call sum() average() function.

What is applicationContext?
applicationContext is the central interface to the Spring IoC container. It is responsible for instantiating, configuring, and assembling the beans in the application. 
It acts as a container that holds all the beans and provides various functionalities such as dependency injection, event propagation, and resource loading.

What is Dependency Injection?
Dependency Injection is a technique where an object receives its dependencies from an external source rather than creating them itself.

What is IoC in Spring?
Inversion of Control (IoC) is a principle where the control of creating and managing objects is transferred from the application code to the framework. In Spring, IoC is 
achieved through the Spring IoC container, which manages the beans and their dependencies.

String str = "I like Marvel Movies";
boolean doesContainsWhiteSpace = StringUtils.containsWhitespace(str);
Here doesContainsWhiteSpace will be true as the string contains white spaces.

We can remove all the white space using another StringUtils method as below:

String newString = StringUtils.trimAllWhitespace(str);
The value of newString in the above case will be IlikeMarvelMovies

clustered Index
Only one clustered index can be there in a table
Sort the records and store them physically according to the order
Data retrieval is faster than non-clustered indexes
Do not need extra space to store logical structure

Non Clustered Index
There can be any number of non-clustered indexes in a table
Do not affect the physical order. Create a logical order for data rows and use pointers to physical data files
Data insertion/update is faster than clustered index
Use extra space to store logical structure
whenever you want to find max or directly reverse order then go for stream.max(Comparator.comparingInt())

The finally block always executes, even if an exception is thrown. But if an exception occurs within finally, it will override any previous exceptions.

       String arr[] = {"apple","orange","banana"};
       long count = String.join("",arr).chars().
       map(ch -> (char)ch).filter(c ->c=='a').count();
       System.out.println(count);
       
       GC is expensive when gc thread starts all application thread is paused.
In concurrent mark and sweep gc thread and application thread works concurrently.but it does not gurantee but it will try its best.In g1 gc it gurantees application thread wont stop along with gc thread and it also ensures memory compaction so that remaining memory can be used effectively.
In heap memory objects are stored in young and old gen. young gen is divided into 3 parts eden,s0,s1 basically survivors.and they are set with age threshold so when they reach the threshold limit they are moved to old gen. in young gen it is minor gc that runs periodically lets say in every 10 secs and in old generation it is called major gc that is lets say runs in every half hours . metaspace is used to store class variables ,static and final variables,constants etc outside the heap memory and metadata about the class. Objects  are freed up from young generation and keeps on moving from eden to s0 and s1 depending upon the mark and sweep algorithm of gc.

Longest String in list
String word=words.stream().max(Comparator.comparingInt(String::length)).get();

List<Integer> numbers = Arrays.asList(1,2,3,4,5);
    Integer max=numbers.stream().max(Integer::compareTo).get();
    
    
   int sum = numbers.stream().reduce(0,(a,b) -> a+b);
   
   second highest number
   List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    int number=numbers.stream().sorted(Comparator.reverseOrder()).skip(1).findFirst()
    .get();
    System.out.println(number);
    
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
Expected Output:


{ "even" -> [2, 4, 6], "odd" -> [1, 3, 5] }
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
  Map<Boolean, List<Integer>> partitioned = numbers.stream()
                .collect(Collectors.partitioningBy(n -> n % 2 == 0));
                
        System.out.println("Even Numbers: " + partitioned.get(true));
        System.out.println("Odd Numbers: " + partitioned.get(false));

String sentence = "The quick brown fox jumps over the lazy dog";
Expected Output:


"jumps"
String sentence = "The quicks brown fox jumps over the lazy dog";
	String longest = Arrays.stream(sentence.split(" ")).max(Comparator.comparingInt(String::length)).get();
	System.out.println(longest);

List<Integer> numbers = Arrays.asList(10, 20, 30, 40, 50);
OptionalDouble average = numbers.stream().mapToInt(Integer::intValue).average();
	
	System.out.println(average);
	
	List<Integer> list1 = Arrays.asList(1, 2, 3, 4);
List<Integer> list2 = Arrays.asList(3, 4, 5, 6);
Expected Output:


[3, 4]
list1.stream().filter(list2::contains).collect(Collectors.toSet()).forEach(System.out::print);

List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");
Expected Output:


["Alice", "Bob", "Charlie"]
List<Integer> firstThree = numbers.stream()
                .limit(3) // Get only the first 3 elements
                .collect(Collectors.toList());
                
                [1, 2, 3, 4, 5, 6]
List<Integer> mergedList = Stream.concat(list1.stream(), list2.stream())
                .collect(Collectors.toList());
                
                 7. Find the highest rank in each department
		 * Map<String, Optional<Student>> studentMap = studentList.stream().collect(Collectors.groupingBy(Student::getDept,Collectors.minBy(Comparator.comparing(Student::getRank))));
		 
		 OptionalDouble sum = numbers.stream().mapToInt(i -> i).average();
		 
		  Optional<Employee> highestPaidEmployees = employees.stream()
                .max(Comparator.comparingDouble(Employee::getSalary));
                
                Problem: Find the maximum value in a list of integers.
    Solution:
    Optional<Integer> max = numbers.stream()
    .max(Integer::compare);
    
    List<String> sentences = Arrays.asList("Hello world", "Java 8 Streams", "flatMap example");

List<String> words = sentences.stream()
    .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
    .collect(Collectors.toList());

System.out.println(words); 
// Output: [Hello, world, Java, 8, Streams, flatMap, example]

Explain how the @Transactional annotation works in Spring. What are the key attributes one should be aware of?
Answer:

The @Transactional annotation in Spring enables declarative transaction management, which means you can handle transactions without explicitly coding them into your business logic. 
It is applied to classes or methods to define the scope of a transaction:

How it Works: When you annotate a method or class with @Transactional, Spring wraps the method call in a transaction. If an exception is thrown within the method, the transaction 
will roll back; otherwise, it will commit at the end of the method execution.
Key Attributes:

propagation: Defines how the transaction should behave when one transaction context calls another. Common values include REQUIRED (default), REQUIRES_NEW (new transaction), NESTED 
(nested transaction within existing one).
isolation: Specifies the transaction isolation level to prevent problems like dirty reads, non-repeatable reads, and phantom reads. Options include READ_COMMITTED, READ_UNCOMMITTED, 
REPEATABLE_READ, SERIALIZABLE.
rollbackFor: Specifies the exception types that should trigger a transaction rollback. By default, only runtime exceptions cause a rollback; checked exceptions do not.
readOnly: If set to true, it hints that the transaction is read-only, which can optimize performance for some transactional resources.
@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, 
                rollbackFor = Exception.class, readOnly = false)
public void saveData(MyData data) {
    // Business logic here
}
In this example, we‚Äôre ensuring a transaction with specific rules about how it should propagate, its isolation level, and that it will rollback for any exception, not just runtime 
ones.

What happens if you have multiple @Transactional annotations in a method call chain?
Answer:

When multiple @Transactional annotations are present in a method call chain:

Propagation: The behavior depends on the propagation attribute of each @Transactional annotation. If a method annotated with @Transactional(propagation = Propagation.REQUIRES_NEW) 
is called from within another transactional method, a new physical transaction will be created for that method, independent of the outer transaction.
Nesting: If methods are annotated with @Transactional but without REQUIRES_NEW, they typically join the existing transaction unless specified otherwise. However, with NESTED, Spring 
uses savepoints within the same physical transaction to allow partial rollbacks.
Outcome: If an exception occurs, the transaction behavior (commit or rollback) depends on the outermost transaction‚Äôs configuration unless inner transactions are configured with 
REQUIRES_NEW or NESTED with savepoints.
This setup can lead to complex transactional boundaries, and understanding how transactions propagate and interact is crucial for managing data consistency in applications.

The default propagation level in Spring is REQUIRED: 
REQUIRED
The default propagation level that creates a new transaction if there isn't one in progress, or uses an existing one if there is. It's the most commonly used propagation level. 
SUPPORTS
Allows a method to participate in a transaction if one exists, but executes non-transactionally if there isn't. 
MANDATORY
Requires a method to execute within an active transaction, and throws an exception if there isn't one. 
REQUIRES_NEW
Always creates a new transaction, and suspends any existing transaction until the new one completes. 
NOT_SUPPORTED
Specifies that a method should execute non-transactionally, regardless of whether there's an active transaction. 
Transaction propagation levels control how @Transactional methods join, use, or create transactions.

is singleton bean scope thread-safe? How to make it thread-safe?
No, a singleton bean scope in Spring is not inherently thread-safe. The singleton scope means that only one instance of the bean is created and shared across the entire application 
context. If this bean maintains state and is accessed by multiple threads simultaneously, it can lead to concurrency issues.

To make a singleton bean thread-safe, you can:

Make the bean stateless: Ensure that the bean does not maintain any state that can be modified by multiple threads.
Use synchronization: Protect shared state with synchronization mechanisms like synchronized blocks or methods.
Use thread-safe data structures: Utilize thread-safe collections and other concurrency utilities provided by the Java java.util.concurrent package.

What is the Life cycle of a Thread?

These are the phases of Thread:

New: Created but not started. when thread created using new keyword
Runnable: Ready to run. when run() method called then thread enters into running state and and it depends on thread scheduler when thread gets the time to get executed by thread scheduler.
Running: Executing.
Blocked/Waiting: Waiting for a resource.
Timed Waiting: Waiting for a specified time.
Terminated: Finished execution.

What happens if run() method is called without start()?

Calling run() Method Without start() in Java

If you call the run() method directly without using the start() method, the run() method will execute in the current thread rather than starting a new thread. This means that no 
new thread is created, and the code inside the run() method runs as a normal method call within the calling thread.

@Retryable in Spring Boot comes from Spring Retry, which allows retrying operations in case of failures like network issues, database errors, or transient exceptions. 
It is useful for handling failures in payment processing, API calls, or database queries.

<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>

import org.springframework.context.annotation.Configuration;
import org.springframework.retry.annotation.EnableRetry;

@Configuration
@EnableRetry
public class RetryConfig {
}

@Service
public class PaymentService {

    @Retryable(
        value = { RestClientException.class },  // Specify exceptions to retry
        maxAttempts = 3,   // Number of retry attempts
        backoff = @Backoff(delay = 2000)  // Wait time before retry (in milliseconds)
    )
    public String processPayment() {
        // Simulate bank API call
        System.out.println("Attempting Payment...");
        
        if (Math.random() < 0.7) { // Simulating failure 70% of the time
            throw new RestClientException("Bank API Failure");
        }
        
        return "Payment Successful";
    }
}
The Predicate is a functional interface defined in java. util. Function package, which accepts an argument and returns a boolean. This is mainly used to filter data from a Java Stream. The filter method of a stream accepts a predicate to filter the data and returns a new stream satisfying the predicate.

The Consumer is a functional interface defined in java. util. Function package, which accepts a single input argument and returns no result. Unlike most other functional interfaces, the Consumer is expected to operate via side effects.

The Supplier is a functional interface defined in java. util. Function package. The Supplier interface takes no argument and returns a result. As this is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. The Supplier has only one get() method and has no default method. In the below example, we created the Supplier object which will be used to supply a new User object.it has get() method while predicate has multiple one of which is test().

The AuthenticationEntryPoint in Spring Security is invoked when an unauthenticated request is received by a secured endpoint. It is responsible for handling authentication failures and initiating the authentication process.
AuthenticationEntryPoint is an interface which posseses the single method commence()
Overall, the commence() method plays a crucial role in handling authentication failures and initiating the authentication process, ensuring that unauthenticated requests are handled appropriately according to the application's security policies.

Iterator allows forward traversal of a collection, while ListIterator extends Iterator
	functionality to allow bidirectional traversal of lists and also supports element
	modification.
	
A process is an executable instance of an application.
	
All static variables are stored in PermGen space of the heap memory.
	
Dirty read occurs when some other transaction reads uncommited transaction data from this transaction.
Suppose if a transaction A reads the same row data multiple times and there is a chance that it gets different value then it is known as non-repeatable read problem.
eg you are reading row 1 status and everytime you got its status free and thats status is changed by some other transaction to booked then when same transaction reads
that row 1 it will get status booked that is non repeatable read problem.
If suppose a transaction A queries the db multiple times and there is a chance that you can get different rows in result set than it is know as phantom read problem.

SELECT a.user_id, a.name, COUNT(o.order_id) AS order_count
FROM Accounts a
JOIN Orders o
ON a.user_id = o.user_id
GROUP BY a.user_id, a.name
HAVING COUNT(o.order_id) < 3;

persistence unit in jpa consists the information about db connections , which sql driver the application is using and dialect the application is using.

FeignClient can be used for both synchronous and asynchronous communication, depending on the project's needs:
Synchronous by default: FeignClient is synchronous by default, but you can make it asynchronous by wrapping it with an async wrapper that returns a CompletableFuture.
CompletableFuture<String> userFuture = CompletableFuture.supplyAsync(() -> 
            userFeignClient.getUserById(userId).getName()
        );
        
Why 1 == 1 is true, but 128 == 128 is false(When data type is Integer otherwise it will give true)
	Java optimizes the memory usage of Integer objects by maintaining a cache of frequently used values. The Integer class caches objects for values between -128 	and 127 by default. This means that:

	For integers in this range, the same object reference is returned for each occurrence of a value.
	For integers outside this range, a new object is created each time.
	
Can we declare the Entity class final?
No, we should not define the entity class final because hibernate uses proxy classes
and objects for lazy loading of data and hits the database only when it is absolutely
needed. This is achieved by extending the entity bean. If the entity class (or bean) is
made final, then it cant be extended and hence lazy loading can not be supported.

The try-with-resources statement was introduced in Java 7 to automatically close resources (like files or database connections) after use. Any class that implements the 
AutoCloseable interface can be used here, reducing the risk of resource leaks.

double d = 1/2; output - 0.0
Double d = 1/2 output - runtime exception int can't be converted to double

int second=list.stream().sorted(Comparator.reverseOrder()).skip(1).findFirst().get();
        System.out.println(second);
        
@SpringBootConfiguration: This annotation essentially replaces
@Configuration and indicates that the class is a source of Spring bean definitions.
@EnableAutoConfiguration: This annotation tells Spring Boot to automatically configure your application based on the dependencies present in your classpath. For example, if you have spring-boot-starter-web on your classpath, it will automatically configure a web server like Tomcat.
@ComponentScan: This annotation tells Spring to scan for components (like @Component, @Service, @Repository, @Controller, etc.) within the package where the @SpringBootApplication class resides and its sub-packages. This allows Spring to discover and register your application's components as beans.

while creating collection objects as immutable create them as final and do not provide setter and initialize via constructor and return the deep copy while initializing
inside the constructor and return defensive copy in getter method.
    public MyImmutableClass(HashMap<KeyType, ValueType> inputMap) {
        // Perform a deep copy of the input map
        this.myImmutableMap = new HashMap<>(inputMap); 
    }
    
        public Map<KeyType, ValueType> getMyImmutableMap() {
        // Option 1: Return a deep copy
        return new HashMap<>(this.myImmutableMap); 

        // Option 2: Return an unmodifiable view
        // return Collections.unmodifiableMap(this.myImmutableMap); 
    }
    
The main differnece between @Autowired and @Inject is that inject is a standard annotation for dependency injection and @autowired is spring specific.

String s="ab12pq34";
        int sum=0;
        for(int i=0;i<s.length();i++){
            if(Character.isDigit(s.charAt(i))){
                sum+=Character.getNumericValue(s.charAt(i));
            }
        }
        System.out.println(sum);
output - 10

int num=1634;
    	int temp=num;
    	int sum=0;
    	while(temp>0) {
    		int rem=temp%10;
    		sum=sum+(rem*rem*rem);
    		temp=temp/10;
    		
    	}

		System.out.println("Sum "+sum+" Num "+num);
    	if(sum==num) {
    		System.out.println("Number is a armstrong number");
    	}else {
    		System.out.println("Number is not a armstrong number");
    	}

int num=1234;
    	int rev=0;
    	while(num>0) {
    		int rem=num%10;
    		rev=(rev*10)+rem;
    		num=num/10;
    	}
    	System.out.println(rev);

int n=31;
    	boolean flag=true;
    	for(int i=2;i<=n/2;i++) {
    		
    		if(n%i==0) {
    			flag=false;
    			break;
    		}
    	}
    	if(flag) {
    		System.out.println("Prime");
    	}else {
    		System.out.println("Not Prime");
    	}


int n=31;
    	for(int i=2;i<=n;i++) {
    	if(isPrime(i)) {
    		System.out.print(i+" ");
    	}
    	

private static boolean isPrime(int num) {
		boolean flag=true; 
		for(int i=2;i<=num/2;i++) {
			if(num%i==0) {
				flag=false;
				break;
			}
		}
		return flag;
	}
	
	comparable provides only one instance to compare and to override its compareTo() method and we use comparator when we want to sort by more than on property.
class RatingCompare implements Comparator<Movie> {
    public int compare(Movie m1, Movie m2)
    {
        if (m1.getRating() < m2.getRating())
            return -1;
        if (m1.getRating() > m2.getRating())
            return 1;
        else
            return 0;
    }
}
 
// Class to compare Movies by name
class NameCompare implements Comparator<Movie> {
    public int compare(Movie m1, Movie m2)
    {
        return m1.getName().compareTo(m2.getName());
    }
}

class Movie implements Comparable<Movie>
{
    private double rating;
    private String name;
    private int year;
 
    // Used to sort movies by year
    public int compareTo(Movie m)
    {
        return this.year - m.year;
    }
 
    // Constructor
    public Movie(String nm, double rt, int yr)
    {
        this.name = nm;
        this.rating = rt;
        this.year = yr;
    }
 
    // Getter methods for accessing private data
    public double getRating() { return rating; }
    public String getName()   {  return name; }
    public int getYear()      {  return year;  }
    
}   

# To visualize the gc logs you can use tools like visual vm to capture the gc logs and to tune the performance adjust the heap size accordingly using xmx xms.

#Find first non repeating integer in a list of Integer
 Integer[] numbers = {4, 5, 1, 2, 0, 4, 5, 2};
        
        Optional<Map.Entry<Integer,Long>> firstNonRepeating = Arrays.stream(numbers).
        collect(Collectors.groupingBy(i->i,LinkedHashMap::new,Collectors.counting()))
        .entrySet().stream().filter(e -> e.getValue()==1)
        .findFirst();
        
        System.out.println(firstNonRepeating.get().getKey());

Here,LinkedHashMap is used as it preserves the insertion order while normal HashMap doesnot gurantee about the insertion order otherwise it will not output the desired output.

future.get() waits for the task to complete and returns the result.

The scenario in which your thread is running for a long time and you need to stop the thread or get its result
you can use Executor.shutdownNow() also to shut down the executor.
Integer result = future.get(); // blocks until computation is done
System.out.println(result);    // prints 20 after ~2 seconds


If the computation is not yet done, get() blocks (pauses current thread) until it finishes.	

Class loading process in java - jvm loads the class the class initializes it and run do static block initialization and runs the static blocks.

one class loader can load the class once and can't be loaded twice.

Arraylist is not threadsafe while copyOnWriteArrayList(also fail safe) is thread safe.       

If @component and @Bean both are defined then @Bean will take precedence as it is externally defined so it will override its defualt enableautoconfiguration mechanism for this.

dependency injection happens in runtime when application context is started.

If your 2 instance is having cron job scheduled and both instance runs the scheduled job. there is a locking way in which db lock is acquired so that only one instance execute it.
their is way of quartz scheduling with clustering in which only one instance is executed. and also running the cron job can be passed to external source like kubernetes in which
we elect the leader pod that will execute it. 

If your endpoint is querying multiple tables and the result received back is taking too long so what should you do. - so instead querying the complete columns fetch only the necessary 
columns and use pagination to fetch large data sets.

@Valid basically if you want to validate your dto class then for whole class @valid is used and if you want to validate on method level or basically in case of get api you can validate the method
with @Validated and put constraints on request params.

if @Table annotation is missing then by default class small name will be taken.

CascadeType.ALL: This is a comprehensive option that cascades all state transitions (persist, merge, remove, refresh, detach) from the parent to the child entities. Any operation on the parent will be automatically propagated to the children.

CascadeType.MERGE: Cascades the merge (update) operation. When a parent entity is merged, its associated child entities will also be merged.

if you have master branch and from that master branch you created one feature branch and you just want to merge only few commits in that case you will use git cherry pick.

String s1 = new String("Java");
       String s2=s1.intern();
       System.out.println(s1==s2);
       output - false
       This above is correct if there was direct assignment then it would have printed true.
       
       Synchronized and Lock interface (renterant lock) are basically both are used when working in multithreaded environment but lock interface ensure fair ordering like can control which thread will
       execute first when comes to thread scheduler.
       
When the objects are no longer referenced by they become eleigible for GC. GC runs periodically and you cannot predict whether it will run. it is devided into young generationa nd old generation
where newly created objects are stored in young gen and short lived objects and those survived young gen using mark and sweep they are passed to old generation and then finally removed from old gen.
to manually make your system eligible for gc use System.gc() or Runtime.getRuntime().gc().
Before destroying an object, the garbage collector calls the finalize() method to perform cleanup activities. The method is defined in the Object class as follows:
Eden: is for initial object allocation.
Survivor spaces: are for objects that have survived initial collection but are still in the Young Generation, acting as a bridge to the Old Generation.
The eden space in Java is a memory pool where objects are created. When the eden space is full, the garbage collector either removes objects if they are no longer in use or stores them in the survivor space if they are still being used. This space is considered part of the young generation in the memory heap.
There are two survivor spaces in the JVM: survivor zero and survivor one. This space is also part of the young generation.
young generation is minor gc and old generation is major gc.
There are two phases in this algorithm: mark followed by sweep.
When a Java object is created in the heap, it has a mark bit that is set to 0 (false).
During the mark phase, the garbage collector traverses object trees starting at their roots. When an object is reachable from the root, the mark bit is set to 1 (true). Meanwhile, the mark bits for unreachable objects is unchanged.
During the sweep phase, the garbage collector traverses the heap, reclaiming memory from all items with a mark bit of 0 (false).

The serial garbage collector is typically used for smaller, single-threaded environments. Don‚Äôt use it in a production environment because the process of garbage collection takes over the thread, freezing other processes. This is known as a ‚Äústop the world‚Äù event.
The parallel garbage collector is JVM‚Äôs default garbage collector. As the name implies this garbage collector uses multiple (parallel) threads. Because it can also use multiple CPUs to speed up throughput, it‚Äôs also known as the throughput collector. However, when running garbage collection, it will also freeze application threads.
Like the parallel garbage collector, the concurrent mark-and-sweep collector uses multiple threads. However, this collector is known as a ‚Äúlow-pause‚Äù collector because it freezes application threads less frequently, making it more appropriate for user-facing applications where ‚Äústop the world‚Äù events will cause issues for your users. It can only garbage collect the old generation concurrently, though‚Äîit still needs to freeze execution when collecting the young generation. Also, because the collector‚Äôs threads execute at the same time as the application‚Äôs threads, it does use more processing power than other garbage collectors.
The G1 garbage collector takes a different approach altogether. Instead of collecting the young and old generations separately, it can collect both at once by splitting the heap into many spaces‚Äînot just the eden, survivor, and tenured spaces that other garbage collectors use. This allows it to clear smaller regions instead of clearing large regions all at once, optimizing the collection process. It runs concurrently like the CMS collector, but it very rarely freezes execution and can collect both the young and old generations concurrently.

List<Employee> sortedList = employees.stream()
    .sorted(
        Comparator.comparing(Employee::getDepartment)
                  .thenComparing(Comparator.comparing(Employee::getSalary).reversed())
                  .thenComparing(Employee::getName)
    )
    .collect(Collectors.toList());
It will sort on the basis of department first if two employee has same department then it will sort by salary if the employee has same salaray also then by name.

List<String> names = Arrays.asList("Alice", "Bob", "Alice", "Alice", "Bob", "Charlie", "Charlie", "Bob");
    
        List<Map.Entry<String, Long>> sortedList=names.stream().collect(Collectors.groupingBy(name -> name,Collectors.counting())).
    entrySet().stream().sorted(
        Comparator.comparing(Map.Entry<String,Long>::getValue,
        Comparator.reverseOrder())
        .thenComparing(Map.Entry::getKey)
        
        ).collect(Collectors.toList());
        
        System.out.println(sortedList);
        
        List<Integer> list = Arrays.asList(1,6,3,8,5,3,7,2,9);
      List<Integer> top3=list.stream().distinct().
      sorted(Comparator.reverseOrder()).limit(3).collect(Collectors.toList());
    
        System.out.println(top3);
        
        List<Integer> list = Arrays.asList(1,6,3,1);
      
      First non repeating ---
      Optional<Map.Entry<Integer,Long>> result = list.stream().
      collect(Collectors.groupingBy(i -> i,LinkedHashMap::new,
      Collectors.counting()))
      .entrySet().stream().
      filter(e -> e.getValue()==1)
      .findFirst();
      
      System.out.println(result.get().getKey());

DI align with open closed principle as ioc container creates new bean without modifying any existing code.

No ‚Äî a lambda expression in Java cannot access non-final local variables.
It can only capture variables that are final or effectively final.

save may schedule the save and may not immediately flushes the changes and after saving it returns unique id. while saveAndFlush() immediately save the changes into db
by synchronizing the state of persistence context and DB.

volatile - All threads will always read the most recent value of the variable from main memory, rather than from their local caches. Any write to a volatile variable is immediately visible to all other threads. while synchronized ensures visibility and atomicity both.

Optimistic Locking with Spring Data:
Concept: This approach is based on the assumption that a data conflict is rare. Instead of locking the data, it checks only when the data is actually updated. This is usually achieved using a version column in the entity.

@Data
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Version
    private int version;

    private String name;

    private double price;
}

With Optimistic Locking (as employed in the example using the @Version annotation):
Read operations (like findById) are non-blocking and can be done in parallel by multiple threads. They don't check or care about the version column.
Write operations (like save) will check the version column to ensure that the data hasn't changed since it was read. If another thread has updated the data in the meantime (and hence, incremented the version number), the save operation will fail with an ObjectOptimisticLockingFailureException.

Pessimistic locking is a strategy that assumes contention for a data item will happen and thus prevents it by locking the item for the duration of a transaction. This approach guarantees that once a thread has a lock, no other thread can access the data until the lock is released.

@Data
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private double price;
}

public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Product> findByIdLocked(Long id);
}

@Service
public class ProductService {
    @Autowired
    private ProductRepository productRepository;

    @Transactional
    public void updatePrice(Long id, double newPrice) {
        Product product = productRepository
            .findByIdLocked(id)
            .orElseThrow(EntityNotFoundException::new);
        product.setPrice(newPrice);
    }
}

The @Lock(LockModeType.PESSIMISTIC_WRITE) annotation ensures that a write lock is obtained when findByIdLocked is invoked.


	Sum of squares of numbers in Integer List
      List<Integer> list = Arrays.asList(1,6);
      
      Integer sum = list.stream().mapToInt(n -> n*n).sum();
      
      System.out.println(sum);
      
      avg of number greater than 10 in list of Integers
      
      List<Integer> list = Arrays.asList(1,6,1,5,13,5,23);
      
      OptionalDouble avg = list.stream().filter(n -> n>10).mapToInt(n->n).average();
      
      System.out.println(avg.getAsDouble());
      
      
      Choreography (Event-based):
      // OrderService
@Transactional
public void createOrder(Order order) {
    orderRepo.save(order);
    kafkaTemplate.send("order-created", order);
}

// PaymentService listens to "order-created"
@KafkaListener(topics = "order-created")
public void handleOrderCreated(Order order) {
    try {
        paymentService.processPayment(order);
        kafkaTemplate.send("payment-success", order);
    } catch (Exception e) {
        kafkaTemplate.send("payment-failed", order);
    }
}

Orchestration (Central controller):
@Service
public class OrderSagaOrchestrator {

    public void startOrderSaga(Order order) {
        try {
            orderService.createOrder(order);
            paymentService.processPayment(order);
            inventoryService.updateStock(order);
        } catch (Exception e) {
            compensate(order);
        }
    }

    private void compensate(Order order) {
        paymentService.refund(order);
        orderService.cancel(order);
    }
}

The Abstract Factory Pattern is a creational design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes.

In simple words ‚Äî it allows you to create objects without exposing the instantiation logic to the client and instead use a common interface to create related objects.

// Abstract products
interface Button {
    void render();
}

interface TextBox {
    void render();
}

// Concrete products - Dark Theme
class DarkButton implements Button {
    public void render() { System.out.println("Dark Button rendered"); }
}

class DarkTextBox implements TextBox {
    public void render() { System.out.println("Dark TextBox rendered"); }
}

// Concrete products - Light Theme
class LightButton implements Button {
    public void render() { System.out.println("Light Button rendered"); }
}

class LightTextBox implements TextBox {
    public void render() { System.out.println("Light TextBox rendered"); }
}

// Abstract factory
interface UIFactory {
    Button createButton();
    TextBox createTextBox();
}

// Concrete factories
class DarkUIFactory implements UIFactory {
    public Button createButton() { return new DarkButton(); }
    public TextBox createTextBox() { return new DarkTextBox(); }
}

class LightUIFactory implements UIFactory {
    public Button createButton() { return new LightButton(); }
    public TextBox createTextBox() { return new LightTextBox(); }
}

// Client
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        UIFactory factory = new DarkUIFactory();
        Button button = factory.createButton();
        TextBox textBox = factory.createTextBox();
        
        button.render();
        textBox.render();
    }
}

Dark Button rendered
Dark TextBox rendered

Bean creation internally uses abstract factory design pattern.

If you remove @SpringbootApplication and use equivalent annotation it will run like normal springboot application.

Suppose you define the same bean (same name or same type) in two different @Configuration classes.

@Configuration
public class ConfigA {
    @Bean
    public DataSource dataSource() {
        System.out.println("Bean from ConfigA");
        return new HikariDataSource();
    }
}

@Configuration
public class ConfigB {
    @Bean
    public DataSource dataSource() {
        System.out.println("Bean from ConfigB");
        return new HikariDataSource();
    }
}

Spring identifies beans by their bean name (default = method name).
In this case, both beans have the name "dataSource".

When the ApplicationContext is initialized:

Spring will detect two beans with the same name.

This causes a conflict unless one is marked as primary or renamed.

output- 
org.springframework.beans.factory.support.BeanDefinitionOverrideException:

You can explicitly allow bean overriding by adding this property:
spring.main.allow-bean-definition-overriding=true

Then, Spring will silently replace the first bean with the second one.
the bean from ConfigB overrides the one from ConfigA.
So only one bean ends up in the ApplicationContext.


If you name them differently:
@Bean("dataSourceA")
public DataSource ds1() { ... }

@Bean("dataSourceB")
public DataSource ds2() { ... }
Both beans will coexist in the context.

You can inject them individually:
@Autowired
@Qualifier("dataSourceA")
private DataSource dsA;

Static variables are stored in heap memory area in permanent generation and the same copy is being shared by all the variables and are created when class is loaded in the memory
class loader and destroyed when class is unloaded.Only one copy exists per class loader, shared among all instances of that class.

# Program to print pallindrome strings in a list of String.
      List<String> list = Arrays.asList("abc","aba","ebe","ebabe");
      
      list.stream().filter(x -> x.equals(new StringBuilder(x).reverse().toString()))
      .forEach(System.out::println);
      
# When working with threads they read value from their cached memory instead of main memory and they can still read the stale cached value. when working with volatile variable it gurantees 
that the value is being read from the main meory instead of the thread local cache so using volatile keyword everytime the most recent value is read and in this way it ensures visibility.

volatile doesn‚Äôt stop this because it only guarantees that the latest read/write is visible, not that the whole read-modify-write sequence happens atomically.

Keyword	Guarantees	Use Case
volatile	Visibility only (no thread ever sees stale data)	When only one thread modifies a shared variable and others just read it
synchronized	Atomicity + Visibility (only one thread executes a critical section at a time)	When multiple threads both read and modify shared data.

Example of volatile - 
public class Worker implements Runnable {
    private volatile boolean running = true; // visibility needed

    @Override
    public void run() {
        while (running) {
            doWork();
        }
    }

    public void stop() {
        running = false; // another thread can update this
    }

    private void doWork() {
        // perform some work
    }
}


Example of synchronized-
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;  // critical section
    }

    public synchronized int getCount() {
        return count;
    }
}

# Escape analysis is a JIT compiler optimization technique which JVM uses internally to ensure performance optimizations By identifying variables that can't be escaped by method so
instead of creating the object on heap it can be created on stack which removes GC overhead and stack follows auto freeing of memory.

public String concatStrings(String a, String b) {
    StringBuilder sb = new StringBuilder();
    sb.append(a);
    sb.append(b);
    return sb.toString();
}

Normally, new StringBuilder() allocates memory on the heap.

But if the JIT compiler can prove that sb does not ‚Äúescape‚Äù the concatStrings method ‚Äî meaning no other thread or code outside this method can access it ‚Äî then:

üëâ The JVM can skip heap allocation
üëâ And instead allocate sb on the stack (which is faster and auto-freed when the method returns).

#Propagation.REQUIRED

‚úÖ ‚ÄúJoin the existing transaction if one exists; otherwise, start a new one.‚Äù

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        serviceB.methodB(); // call another transactional method
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB() {
        // ...
    }
}

What happens:

methodA() starts a new transaction.

methodB() sees there‚Äôs already one, so it joins the same transaction.

If either throws an exception ‚Üí the entire transaction rolls back.

‚úÖ One unified transaction context.     

Propagation.REQUIRES_NEW

üöÄ ‚ÄúAlways start a brand-new transaction, suspending any existing one.

If a transaction already exists ‚Üí pause it.

Start a completely new independent transaction.

When done ‚Üí commit/rollback this inner transaction.

Then resume the outer transaction.

#Use required when you want uniform business logic that need to be commit or rollback whole.
required_new in case of logging , auditing.

#Whenever you modify data (INSERT, UPDATE, DELETE), the DB must:
Write to the main table (data pages)
Update every index that references the affected column(s)
So, each index adds extra work per write operation.

#The difference between @ControllerAdvice and @RestControllerAdvice is @ControllerAdvice is used with web MVC and it returns the view name as returned in RestController and
@RestControllerAdvice is used to return json in response. and @ControllerAdvice works with both @Controller and @RestController.
If both are present in the springboot application and both have same type of @ExceptionHandler then exception thrown by Rest Controller will be handled by @ControllerAdvice and it will 
return view and error thrown by @RestController will be entertained @RestControllerAdvice and json is returned in response.

Aspect		ExecutorService											ForkJoinPool
Definition	A general-purpose thread pool used to execute Runnable or Callable tasks asynchronously.	A specialized implementation of ExecutorService designed for parallel computation using 			 																							the Fork/Join framework.
Introduced in	Java 5 (java.util.concurrent)	Java 7 (java.util.concurrent)
Best for	Independent, unrelated tasks (e.g., IO tasks, background jobs).	Recursive, divide-and-conquer tasks (e.g., parallel computation, large data processing).
Thread Management	Uses a fixed or cached thread pool ‚Äî one thread per task.	Uses a work-stealing algorithm for efficient CPU utilization.
Task Type	Runnable, Callable<T>	RecursiveTask<V> or RecursiveAction

"Reentrant" means that the same thread can acquire the lock multiple times without blocking itself.
That is, if a thread already holds the lock, and it tries to lock again (within a nested call), it will succeed immediately ‚Äî not deadlock.
It comes with the timeout aslo it try locking for some time unit.

RestTemplate -
Synchronous (blocking) HTTP client.
Works well in traditional Spring MVC applications.
Each request blocks the thread until a response is received.

WebClient (Reactive HTTP Client) - 
Non-blocking, reactive alternative to RestTemplate.
Built on Reactor (Project Reactor / Mono / Flux).
Designed for Spring WebFlux but works in non-reactive apps too.
Thread doesn‚Äôt wait ‚Äî efficient for high concurrency.

Feign Client (Declarative HTTP Client) - 
Provided by Spring Cloud OpenFeign.
Declarative ‚Äî you just define an interface, no boilerplate code.
Internally can use RestTemplate or WebClient depending on config.
Ideal for microservice-to-microservice calls (like in a Spring Cloud system).

HikariCP is default connection pooling mechanism.

Feature	G1 GC (Garbage First)	ZGC (Z Garbage Collector)
Introduced In	Java 9 (default from Java 9‚Äì13)	Java 11 (production-ready since Java 15) 
Goal	Balance between throughput and low pause time	Ultra-low pause time regardless of heap size
Pause Time Target	< ~200 ms (tunable)	< 10 ms (typically 1‚Äì2 ms)

#acks=0 fire and forget doesn't wait for any confirmation.
 acks=1 wait for the leader to confirm the leader that data is written.
 acks=all or -1 ensures that leader and all follower must confirm about the data write.
 
#Kafka Producer first:

Serializes the key using key.serializer
Serializes the value using value.serializer
Assigns a timestamp (event time or ingestion time)
Performs partitioning using the partitioner

Producer Determines the Partition
The default Kafka partitioner chooses partition:
If key is present ‚Üí hash(key) % number_of_partitions
If no key ‚Üí round-robin sequence
This ensures ordering within a partition.

ArrayList ‚Äî Use When You Need
Fast random access (index-based reads)
get(index) ‚Üí O(1)
Because ArrayList stores data in a contiguous array.
Frequent read operations
Perfect for read-heavy workloads.

LinkedList ‚Äî Use Only When:
Frequent insertions/deletions in the middle
Removing/adding at known position ‚Üí O(1)
(but‚Ä¶ only if you already have a reference to the node)

Interfaces ensures loose coupling and in abstract class class are closely related.

@PrePersist and @PreUpdate are JPA lifecycle callbacks used to execute logic automatically before an entity is inserted or updated in the database.

@PrePersist - Executed right before JPA/Hibernate performs an INSERT.
Used for initialization tasks at the time of creation.
Common use cases:
Set createdAt timestamp
Set default values
Initialize audit fields
Generate identifiers (if not using DB)

@PreUpdate - Executed right before JPA/Hibernate performs an UPDATE.
Used for updating fields whenever the entity changes.
Common use cases:
Update updatedAt timestamp
Modify audit fields (modifiedBy)
Recalculate derived fields

#sort employees by salary then by name
List<Employee> sortedList =
        employees.stream()
                 .sorted(Comparator.comparing(Employee::getSalary)
                                   .thenComparing(Employee::getName))
                 .collect(Collectors.toList());

employees.stream()
         .sorted(Comparator.comparing(Employee::getSalary).reversed()
                           .thenComparing(Comparator.comparing(Employee::getName).reversed()))
         .collect(Collectors.toList());

Using @AutoConfigureBefore / @AutoConfigureAfter
These annotations control the order in which auto-configurations run.
Useful when:
You want to override an existing auto-config
You want your beans to be available earlier
You need to prepare something before a Spring Boot auto-config executes

Initializing bean has method afterPropertiesSet() and disposablebean has method destroy().

A LazyInitializationException in Hibernate/JPA occurs when you try to access a LAZY-loaded association outside of an active Hibernate session (i.e., outside the transaction in which the entity was loaded).
When an entity is loaded inside a transaction, Hibernate attaches it to a persistence context (session).
Once the transaction ends:
the session is closed
the proxy representing the LAZY field is still there
but Hibernate cannot load the data anymore
When code tries to access a lazy field after the session is closed, Hibernate throws:

org.hibernate.LazyInitializationException: 
failed to lazily initialize a collection, could not initialize proxy - no Session

If you access LAZY fields outside of a @Transactional method, Hibernate cannot fetch the data ‚Üí exception.

Optimistic locking assumes low contention (rare concurrent updates).
It does NOT block other transactions.
Instead, each update checks if another transaction modified the row in between.
Hibernate uses a @Version column to detect conflicts.

How it works internally:
Read entity ‚Üí version = 1
Modify entity in memory
When committing:
Hibernate runs:
UPDATE table SET data=?, version = version + 1 
WHERE id=? AND version=1
If row count = 0, another transaction updated it ‚Üí OptimisticLockException.
@Version
private Long version;

Advantages:
No database locks
Non-blocking
Best for read-heavy systems
Scales well

Pessimistic Locking (Database row locking)
Pessimistic locking assumes high contention.
It locks the row in the database to prevent concurrent writes or reads.

How it works internally:
When you read a row with a lock, DB executes:
SELECT * FROM table WHERE id=? FOR UPDATE;
This locks the row:
other transactions cannot update
depending on lock type, cannot read either
JPA example:
User user = entityManager.find(User.class, id, LockModeType.PESSIMISTIC_WRITE);

Advantages:
Prevents conflicts upfront
Ideal for high write contention
Guaranteed consistency

@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdForUpdate(@Param("id") Long id);

Corresponding sql - SELECT ... FOR UPDATE

@Lock(LockModeType.PESSIMISTIC_WRITE)
Blocks both reads and writes by other transactions.

@Lock(LockModeType.PESSIMISTIC_READ)
Prevents writes, but allows concurrent reads.

static variables are stored in metaspace of permgen heap memory.
stream api is lazy in nature it won't be invoked untill any terminal operation is called on it.

What is @Secured?
A simple role-based annotation.
‚úî Supports only roles
‚úî Does not support Spring Expression Language (SpEL)
Example:
@Secured("ROLE_ADMIN")
public void deleteUser() {}
To use it, you must enable:
@EnableGlobalMethodSecurity(securedEnabled = true)

What is @PreAuthorize?
A more powerful annotation that uses SpEL.
Supports roles
Supports permissions
Supports dynamic business logic
Works on method arguments

Example:
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser() {}
Enable it:
@EnableGlobalMethodSecurity(prePostEnabled = true)

If fallback method itself fails then we throw the exception and propagate the exception.

1st priority - command line argument , environment property,config server,default properties file.

If there is no ExceptionHandler in springboot then springboot will use its default exception handler and return its default 500 error response.

Covariant return types allow a subclass to override a method and return a more specific (child) type than the method in the parent class.
This feature was introduced in Java 5
When overriding a method, the return type in the subclass can be a subtype of the return type defined in the superclass.

class AnimalService {
    Animal getAnimal() {
        return new Animal();
    }
}

Child method overriding with covariant return:
class DogService extends AnimalService {
    @Override
    Dog getAnimal() {
        return new Dog();
    }
}
This is valid because Dog is-a Animal.

merge() is a method provided by EntityManager to update (or create) an entity in the database by returning a managed copy of the entity.
merge() does NOT update the passed object
It creates a new managed entity instance, copies fields from your object into it, and returns it.

save() always performs insert and in spring data jpa there is no saveOrUpdate() so save() behaves like saveOrUpdate().

Normalization is the process of structuring a database to reduce redundancy and improve data integrity.
Goal
Avoid duplicate data
Ensure consistency
Improve update performance

How it looks
Data is split into multiple related tables using primary keys & foreign keys.

Denormalization is the process of intentionally adding redundancy to improve read/query performance.
Goal
Make reads faster
Reduce JOINs
Support analytics/reporting

How it looks
Data is combined into fewer tables by copying values.

Normalization ‚Üí Remove redundancy, more tables, more joins, consistent data.
Denormalization ‚Üí Add redundancy, fewer joins, faster reads, risk of inconsistency.

| Method            | When Value Present | When Value Missing            | Execution Style                      | Use Case                       |
| ----------------- | ------------------ | ----------------------------- | ------------------------------------ | ------------------------------ |
| **orElse()**      | Returns value      | Returns default value         | Default object is **always created** | Simple default values          |
| **orElseGet()**   | Returns value      | Calls Supplier to get default | Lazy evaluation                      | Expensive default construction |
| **orElseThrow()** | Returns value      | Throws exception              | Lazy                                 | Mandatory value must exist     |

public String getUserName(Optional<String> nameOpt) {

    String name1 = nameOpt.orElse("Guest");  
    // "Guest" is created immediately

    String name2 = nameOpt.orElseGet(() -> getDefaultName());  
    // getDefaultName() executed only if needed

    String name3 = nameOpt.orElseThrow(() -> new RuntimeException("Name missing"));
    // throws exception if name not present

    return name1; // Just example
}

The Fork/Join framework helps break a large task into multiple small tasks (called subtasks) that can execute in parallel using multiple CPU cores.
It uses a special thread pool called ForkJoinPool, which uses the work-stealing algorithm to keep threads busy.
Basic Flow

fork() ‚Üí split the large task into smaller tasks
compute() ‚Üí execute tasks
join() ‚Üí merge results

how does pattern matching for instanceof simplify java code?
Pattern matching for instanceof (introduced in Java 16) simplifies Java code by removing the need for manual casting after an instanceof check.
Before pattern matching:
You check instanceof
Then you explicitly cast the object
This creates boilerplate, is error-prone, and makes code verbose.

Without Pattern Matching (Old Java Code)
Object obj = ...;

if (obj instanceof String) {
    String s = (String) obj;   // manual cast needed
    System.out.println(s.toLowerCase());
}

With Pattern Matching for instanceof (Modern Java)
Object obj = ...;

if (obj instanceof String s) {
    System.out.println(s.toLowerCase());
}

#group employees by department and get the higghest salary per department
Map<String, Optional<Employee>> highestSalaryByDept =
        employees.stream()
                .collect(Collectors.groupingBy(
                        Employee::getDepartment,
                        Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))
                ));

JIT (Just-In-Time Compiler) is a key component of the Java Virtual Machine (JVM) that improves the performance of Java applications by compiling bytecode into native machine code at runtime.
When you run Java code:
Java compiler (javac) converts .java ‚Üí .class (bytecode)
JVM initially interprets bytecode line-by-line (slow)
JIT compiler detects frequently used code ("hot code")
JIT converts that bytecode into native machine code
Next time that code runs ‚Üí it executes directly on the CPU, much faster

Parallel streams does not produce invalid result untill they share some common shared resource and can be saved from race conditon by using synchronized collection for example.

If HikariCP is enabled by default (as in Spring Boot), then the default maximum number of connections in the pool = 10.

List<Integer> list = Arrays.asList(10, 25, 13, 41, 152, 19, 22);

List<Integer> result = list.stream()
        .filter(num -> String.valueOf(num).startsWith("1"))
        .toList();

System.out.println(result);

Map<String, Long> genderCount =
        employees.stream()
                 .collect(Collectors.groupingBy(Employee::getGender,
                          Collectors.counting()));

System.out.println(genderCount);

Map<String, Double> avgSalaryByGender =
        employees.stream()
                 .collect(Collectors.groupingBy(
                         Employee::getGender,
                         Collectors.averagingDouble(Employee::getSalary)
                 ));

System.out.println(avgSalaryByGender);

List<Integer> list = List.of(2,3,4,5,6,7,8);
        Integer sum = list.stream().filter(i -> i%2!=0).mapToInt(i -> i).sum();
        System.out.println(sum);

Map<Boolean,List<Integer>> map = list.stream().
        collect(Collectors.partitioningBy(i -> i%2==0));

String input = "banana";
char remove = 'a';

String result = input.chars()
        .filter(ch -> ch != remove)
        .mapToObj(ch -> String.valueOf((char) ch))
        .collect(Collectors.joining());

System.out.println(result);

public class SpecialCharFinder {
    public static void main(String[] args) {
        String input = "Hello@World#123!";

        input.chars()
                .mapToObj(c -> (char) c)
                .filter(c -> !Character.isLetterOrDigit(c))
                .forEach(System.out::println);
    }
}

public class HalfUpperHalfLower {
    public static void main(String[] args) {
        String input = "Programming";

        int mid = input.length() / 2;

        String firstHalf = input.substring(0, mid).toUpperCase();
        String secondHalf = input.substring(mid).toLowerCase();

        String result = firstHalf + secondHalf;

        System.out.println(result);
    }
}

List<Integer> list = List.of(12,3,4,5,6,7,8);
        Integer max = list.stream().
        max(Integer::compare).get();
        System.out.println(max);

Type	What is passed	Effect in method
Primitive	Actual value	Original value unaffected
Object	Reference value	Object can be modified, reference itself cannot

given a list of transactions - find top 3 customers by total spending
transactions.stream()
        .collect(Collectors.groupingBy(
                Transaction::getCustomerId,
                Collectors.summingDouble(Transaction::getAmount)
        ))
        .entrySet().stream()
        .sorted((e1, e2) -> (int)(e2.getValue() - e1.getValue())) // simple lambda
        .limit(3)
        .forEach(entry ->
                System.out.println(entry.getKey() + " : " + entry.getValue())
        );

Spring singleton beans and manual singleton utilities serve different purposes.
If you are inside a Spring-managed app, you usually don‚Äôt need manual singleton.
If you need global access outside Spring, legacy code, or utility classes, a singleton pattern is still useful.

Feature	Spring REST API	Spring MVC
Response Type	JSON/XML	HTML/JSP/Thymeleaf
Client	Any	Web browser
Stateless	‚úÖ	Usually ‚ùå (uses session)
Scalability	High	Moderate
Front-end Integration	Easy (SPA)	Harder
HTTP Semantics	Fully leveraged	Partially
Microservices	‚úÖ	‚ùå

Use REST APIs when building modern, scalable, and client-agnostic services (mobile, SPA, microservices).
Use Spring MVC when you need server-rendered pages (traditional websites).

Map<String, List<Employee>> top5ByDept = employees.stream()
        .collect(Collectors.groupingBy(
                Employee::getDepartment,
                Collectors.collectingAndThen(
                        Collectors.toList(),
                        list -> list.stream()
                                .sorted((e1, e2) -> Double.compare(e2.getSalary(), e1.getSalary())) // descending
                                .limit(5)
                                .toList()
                )
        ));

calculate totals by user id using streams
Map<String, Double> totalsByUser = transactions.stream()
        .collect(Collectors.groupingBy(
                Transaction::getUserId,
                Collectors.summingDouble(Transaction::getAmount)
        ));
