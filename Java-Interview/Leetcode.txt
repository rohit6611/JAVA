1) Program to rotate array by specific number of position

Array rotation
class Array_Rotation
{

// Function to rightRotate array
static void RightRotate(int a[], 
                        int n, int k)
{
    
    // If rotation is greater 
    // than size of array
    k=k%n;

    for(int i = 0; i < n; i++)
    {
        if(i<k)
        {
            // Printing rightmost 
            // kth elements
            System.out.print(a[n + i - k] 
                             + " ");
        }
        else
        {
            // Prints array after
            // 'k' elements
            System.out.print(a[i - k] 
                             + " ");
        }
    }
    System.out.println();
}

If want to replace the elements of the same array then 
follow the approach-
1) Reverse 0 to arr length;
2) 0 to K-1(position by which you want to reverse array)
3) k+1 to arr length

class Solution {
    public void rotate(int[] nums, int k) {
        
        int n=nums.length;
        k=k%n;
        reverse(nums,0,n-1);
        reverse(nums,0,k-1);
        reverse(nums,k,n-1);
        
    }
    void reverse(int[] nums,int i,int j){
        while(i<j){
            swap(nums,i,j);
            i++;
            j--;
        }
    }

    void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}

2) spiral order printing of matrix
everything will go alternatively ie left right and top and bottom.

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {

    int top=0;
    int bottom=matrix.length-1;
    int left=0;
    int right=matrix[0].length-1;
    List<Integer> result=new ArrayList<>();
    while(left<=right && top<=bottom){
        
        for(int i=left;i<=right;i++){
            result.add(matrix[top][i]);
        }
        top++;
        for(int i=top;i<=bottom;i++){
            result.add(matrix[i][right]);
        }
        right--;
        if(top<=bottom){
            for(int i=right;i>=left;i--){
                result.add(matrix[bottom][i]);
            }
            bottom--;
        }
        if(left<=right){
            for(int i=bottom;i>=top;i--){
                result.add(matrix[i][left]);
            }
            left++;
        }
    }    
    return result;
    
    }
}

1. when you write brute force of any solution and you are unable to identify how to optimize the problem then you should check
# if there is any repeatative work you are doing.

In fixed size window
while(j<N){
calc
if(j-i+1<k) j++;
else

ans from calculation
slide the window;


}


3.) Sliding window to find the max subarray of size K

        
        int i=0,j=0;
        int n=nums.length;
        int sum=0;
        int mx=Integer.MIN_VALUE;

        while(j<n){
            sum=sum+nums[j];
            if(j-i+1<k){
                j++;
            }
            else if(j-i+1==k){
                mx=Math.max(sum,mx);
                sum=sum-nums[i];
                i++;j++;
            }


        }
    return Long.valueOf(mx);

4.) Find first negative in window of size K

in calculation you know if number is negative you need to add it in your ans so add it in list .
and when you are sliding the window then you need to remove it from the list as you aren't gonna need it in upcoming window.

int i=0,j=0,k=0;
        List<Long> negativeArray=new ArrayList<>();
        long[] ans=new long[N-K+1];
        
        while(j<N){
            
            if(A[j]<0){
                negativeArray.add(A[j]);
            }
            if(j-i+1<K){
                j++;
            }else if(j-i+1==K){
                if(negativeArray.size()>0){
                ans[k++]=negativeArray.get(0);
                }else{
                    ans[k++]=0;
                }
                if(negativeArray.contains(A[i])){
                    negativeArray.remove(A[i]);
                }
                i++;j++;
            }
            
            
            
        }
        return ans;

5.) Count occurrence of anangrams

int result = 0;
        int i = 0; // starting point
        int j = 0; // end point
        int k = pat.length(); // window size

        // Char set
        HashMap<Character, Integer> charCounts = new HashMap<>();
        for (int s = 0; s < pat.length(); s++) {
            char c = pat.charAt(s);
            charCounts.put(c, charCounts.getOrDefault(c, 0) + 1);
        }
        int count = charCounts.size();

        // Sliding window
        while (j < txt.length()) {
            char currentChar = txt.charAt(j);
            if (charCounts.containsKey(currentChar)) {
                charCounts.put(currentChar, charCounts.get(currentChar) - 1);
                if (charCounts.get(currentChar) == 0)
                    count--;
            }
            if ((j - i + 1) < k) {
                j++;
            } else if ((j - i + 1) == k) {
                if (count == 0)
                    result++;
                char firstChar = txt.charAt(i);
                if (charCounts.containsKey(firstChar)) {
                    charCounts.put(firstChar, charCounts.get(firstChar) + 1);
                    if (charCounts.get(firstChar) == 1)
                        count++;
                }
                i++;
                j++;
            }
        }
        return result;

6.) Maximum of all subarrays of size k



//User function template for JAVA

class Solution
{
    //Function to find maximum of each subarray of size k.
    static ArrayList <Integer> max_of_subarrays(int arr[], int n, int k)
    {
       

       Deque<Integer> deque = new LinkedList<Integer>();
       ArrayList <Integer> res = new ArrayList<>();
       
       for(int i = 0, j = 0; j < n;j++)
       {
           while(!deque.isEmpty() &&  deque.peekLast() < arr[j])
                deque.pollLast();
          
          deque.addLast(arr[j]);
          
          if((j-i+1) == k)
          {
             res.add(deque.peekFirst());
             
             if(deque.peekFirst() == arr[i])
                deque.pollFirst();
             
             i++;
          }
     
       }
       
       return res;
    }
}

7.) Maximum subaara wth sum k

class Solution {
    public int subarraySum(int[] nums, int k) {
        
        int i=0,j=0;
        int max=Integer.MIN_VALUE;
        int sum=0;

        while(j<nums.length){
            sum+=nums[j];
            if(sum==k){
                max=Math.max(max,j-i+1);
              
            }
                while(sum>k && i<=j){
                    sum=sum-nums[i];
                    i++;
                }
             j++;
                        

        }
        return max;
    }
}

General format for variable size window.

while(j<size){

calculations
if(cond<k){
j++;
}
else if(condition==k){
ans -> calculation
j++;

}
else if(condition>k){
while(cond>k){
remove calculation for i
i++;
}
j++;
}

}

8.) Longest subarray with sum k

class Solution{
    
   
    // Function for finding maximum and value pair
    public static int lenOfLongSubarr (int A[], int N, int K) {
        //Complete the function
        int i=0,j=0;
        int max=0;
        int sum=0;
        
        while(j<N){
            sum=sum+A[j];
            if(sum==K){
                max=Math.max(max,j-i+1);
            }
            while(sum>K && i<=j){
                sum=sum-A[i];
                i++;
            }
            j++;
            
        }
        return max;
    }
    
    
}

# Longest k unique character substring.
class Solution {
    public int longestkSubstr(String s, int k) {
      
      int i=0,j=0;
      HashMap<Character,Integer> map=new HashMap<>();
      int max=-1;
      
      while(j<s.length()){
          
          if(map.containsKey(s.charAt(j))){
              map.put(s.charAt(j),map.get(s.charAt(j))+1);
          }else{
              map.put(s.charAt(j),1);
          }
          if(map.size()==k){
              max=Math.max(max,j-i+1);
              j++;
          }
          if(map.size()<k){
              j++;
          }
          if(map.size()>k){
          while(map.size()>k){
              
              map.put(s.charAt(i),map.get(s.charAt(i))-1);
              if(map.get(s.charAt(i))==0){
                  map.remove(s.charAt(i));
                  
              }
              i++;
          }
          j++;
          }
          
      }
      return max;
    }
}

9.) Longest substring without repeating characters

Note that the length of the window should be equal to the map.size() so that uniqueness should be maintained.

class Solution {
    public int lengthOfLongestSubstring(String s) {
        
        int i=0,j=0;
        int n=s.length();
        HashMap<Character,Integer> map=new HashMap<>();
        int max=0;
        while(j<n){

            if(map.containsKey(s.charAt(j))){
              map.put(s.charAt(j),map.get(s.charAt(j))+1);
          }else{
              map.put(s.charAt(j),1);
          }
            if(map.size()==j-i+1){
                max=Math.max(max,j-i+1);
                j++;
            }
            else if(map.size()<j-i+1){
                while(map.size()<j-i+1){
                    map.put(s.charAt(i),map.get(s.charAt(i))-1);
                     if(map.get(s.charAt(i))==0){
                  map.remove(s.charAt(i));
                    }
                    
                i++;             
                }
                j++;
            }else{
                j++;
            }


        }
        return max;
    }
}

10.) Minimum window substring.
Hardest and Threshhold problem.

class Solution {
    public String minWindow(String s, String t) {
        int n = s.length();
        HashMap<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
        }
        
        int count = map.size();
        int minLen = Integer.MAX_VALUE;
        String minStr = "";
        int i = 0, j = 0;
        
        while (j < n) {
            char currentChar = s.charAt(j);
            if (map.containsKey(currentChar)) {
                map.put(currentChar, map.get(currentChar) - 1);
                if (map.get(currentChar) == 0) {
                    count--;
                }
            }
            j++;
            
            while (count == 0) {
                if (j - i < minLen) {
                    minLen = j - i;
                    minStr = s.substring(i, j);
                }
                
                char leftChar = s.charAt(i);
                if (map.containsKey(leftChar)) {
                    map.put(leftChar, map.get(leftChar) + 1);
                    if (map.get(leftChar) > 0) {
                        count++;
                    }
                }
                i++;
            }
        }
        
        return minStr;
    }
}

11.) count distinct character in every window.

class Solution {
    public String minWindow(String s, String t) {
        int n = s.length();
        HashMap<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
        }
        
        int count = map.size();
        int minLen = Integer.MAX_VALUE;
        String minStr = "";
        int i = 0, j = 0;
        
        while (j < n) {
            char currentChar = s.charAt(j);
            if (map.containsKey(currentChar)) {
                map.put(currentChar, map.get(currentChar) - 1);
                if (map.get(currentChar) == 0) {
                    count--;
                }
            }
            j++;
            
            while (count == 0) {
                if (j - i < minLen) {
                    minLen = j - i;
                    minStr = s.substring(i, j);
                }
                
                char leftChar = s.charAt(i);
                if (map.containsKey(leftChar)) {
                    map.put(leftChar, map.get(leftChar) + 1);
                    if (map.get(leftChar) > 0) {
                        count++;
                    }
                }
                i++;
            }
        }
        
        return minStr;
    }
}

12.) longest subarray with sum divisible by k


class Solution{
    int longSubarrWthSumDivByK(int a[], int n, int k)
    {
        // Complete the function
        HashMap<Integer,Integer>remmap=new HashMap<>();
        remmap.put(0,-1);
        int sum=0, maxlen=0;
        for(int i=0;i<n;i++){
            sum+=a[i];
            int rem=sum%k;
            if(rem<0){
                rem+=k;
            }
            if(remmap.containsKey(rem)){
                int len=i-remmap.get(rem);
                maxlen=Math.max(maxlen,len);
            }
            else{
                remmap.put(rem,i);
            }
        }
        return maxlen;
       
    }
}

13.) smallest distinct window


class Solution {
    public int findSubString( String str) {
       int i = 0, j = 0;
        int n = str.length();
        int min = Integer.MAX_VALUE;
        Map<Character, Integer> map = new HashMap<>();
        HashSet<Character> hashSet = new HashSet<>();
        for (int k = 0; k < str.length(); k++) {
            hashSet.add(str.charAt(k));
        }
        int count = hashSet.size();
        String result = "";
        while (j < n) {
            if(map.size()<count){
            if (map.containsKey(str.charAt(j))) {
                map.put(str.charAt(j), map.get(str.charAt(j)) + 1);
            } else {
                map.put(str.charAt(j), 1);
            }
            j++;
            }
                while (map.size() == count) {
                
                min=Math.min(min,j-i);
                    map.put(str.charAt(i), map.get(str.charAt(i)) - 1);
                    if (map.get(str.charAt(i)) == 0) {
                        map.remove(str.charAt(i));
                    }
                    i++;
            }
        }
       
        return min;
       
           
           
       }
    }

14.) no of subarrays with sum k

class Solution {
    public int subarraySum(int[] nums, int k) {
        
        int i=0,j=0;
        int max=Integer.MIN_VALUE;
        int sum=0;
        int count=0;

        while(j<nums.length){
            sum+=nums[j];
            if(sum==k){
                max=Math.max(max,j-i+1);
                count++;
                j++;
            }
            if(sum<k){
                j++;
            }
           if(sum>k){
                while(sum>k && i<=j){
                    sum=sum-nums[i];
                    i++;
                }
                j++;
           }                                  

        }
        return count;
    }
}

15.) maximum length of subaaray with equal no of 0 and 1

class LongestSubArray {

  public static void findMaxLength(int[] arr) {

    // write your code here
    int max = 0;

    HashMap < Integer, Integer > map = new HashMap < > ();
    map.put(0, -1); // at the starting we will put -1 for 0

    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == 0) {
        sum += -1; //whenever we have 0 = -1
      } else if (arr[i] == 1) {
        sum += +1; // whenever we have 1 = 1
      }
      if (map.containsKey(sum)) {
        int idx = map.get(sum);
        int length = i - idx;
        if (length > max) {
          max = length;
        }
      } else {
        map.put(sum, i);
      }

    }
    System.out.println("The length of the longest subarray is: " + max);

  }

16.)find index of subarrays with given sum

class Solution
{
    //Function to find a continuous sub-array which adds up to a given number.
    static ArrayList<Integer> subarraySum(int[] arr, int n, int s) 
    {
       
       HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1); // Initialize the hashmap with sum 0 and index -1
        int sum = 0;
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            sum += arr[i];
            int complement = sum - s;
            if (map.containsKey(complement)) {
                int startIdx = map.get(complement) + 1;
                int endIdx = i;
                list.add(startIdx + 1); // Adjust index by adding 1 (1-based index)
                list.add(endIdx + 1); // Adjust index by adding 1 (1-based index)
                return list;
            } else {
                map.put(sum, i);
            }
        }

        list.add(-1); // If no subarray is found, return -1
        return list;
    }
}

17.) subrry with sum 0

class Solution{
    //Function to check whether there is a subarray present with 0-sum or not.
    static boolean findsum(int arr[],int n)
    {
       HashMap<Integer,Integer> map=new HashMap<>();
       map.put(0,-1);
       int sum=0;
       boolean isPresent=false;
       for(int i=0;i<n;i++){
           sum+=arr[i];
           if(map.containsKey(sum)){
               isPresent=true;
               break;
           }else{
               map.put(sum,i);
           }
           
           
       }
       return isPresent;
    }
}

18.) Count no of binary strings

class Solution {
    public int countBinarySubstrings(String s) {
        
        int i=0,j=0;
        HashMap<Integer,Integer> map=new HashMap<>();
        map.put(0,-1);
        int sum=0;
        int count=0;
        while(j<s.length()){
            if(s.charAt(j)=='0'){
                sum+=-1;
            }else{
                sum+=+1;
            }
            if(map.containsKey(sum)){
                count++;
            }else{
                map.put(sum,j);
            }
            j++;


        }
        return count;
    }
}


